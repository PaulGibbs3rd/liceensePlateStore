{"version":3,"file":"static/js/69008.92fafa40.chunk.js","mappings":";qbA6BA,SAASA,EAAYC,EAAWC,EAAWC,GACzC,IAAMC,EAAKF,EAAG,GAAKD,EAAG,GAChBI,EAAKH,EAAG,GAAKD,EAAG,GACtB,OAAOG,GAAO,EAAIC,EAAMD,EAAKD,GAAK,EAAIA,CACxC,CAeA,SAASG,EAAOL,EAAWC,EAAWK,EAAYC,EAAYC,GAC5D,cAAiBR,EAAE,GAAZS,EAAE,KAAEC,EAAE,KACb,UAAiBT,EAAE,GAAZU,EAAE,KAAEC,EAAE,KACPT,GAAMQ,EAAKF,GAAM,EACjBI,EAAKL,EAAE,CAACC,EAAKN,EAAIO,EAAKP,EAAKG,IAAKQ,KAAK,KACrCC,EAAKP,EAAE,CAACG,EAAKR,EAAIS,EAAKT,EAAKI,IAAKO,KAAK,KACrCE,EAAIR,EAAE,CAACG,EAAIC,IAAKE,KAAK,KAC3B,MAAO,KAAP,OAAYD,EAAE,YAAIE,EAAE,YAAIC,EAC1B,UAkDgBC,EAAK,GAA4B,IAA1BC,EAAI,EAAJA,KAAMC,EAAG,EAAHA,IAAKC,EAAG,EAAHA,IAAKZ,EAAC,EAADA,EACrC,GAAoB,IAAhBU,EAAKG,OACP,MAAO,GAIT,IAKInB,EACAF,EACAC,EAPJ,EAAyBO,EAAEU,EAAK,IAAGI,GAAAA,EAAAA,EAAAA,GAAAA,EAAAA,GAA5BC,EAAM,KAAEC,EAAM,KACrB,EAAqBhB,EAAEW,GAAIM,GAAAA,EAAAA,EAAAA,GAAAA,EAAAA,GAApBC,EAAI,KAAEC,EAAI,KACjB,EAAenB,EAAEY,GAAVQ,GAAcC,EAAAA,EAAAA,GAAAA,EAAAA,GAAV,GAQLC,EAAWZ,EAAKa,QAAO,SAACC,EAAKC,EAAOC,GAGxC,GAFAlC,EAAKkB,EAAKgB,EAAI,GACdjC,EAAKiB,EAAKgB,EAAI,GACVA,EAAI,EAAG,CACT,IAAM3B,EAnHZ,SAAeP,EAAWC,EAAWkC,GACnC,IAAMhC,EAAKF,EAAG,GAAKD,EAAG,GAChBoC,EAAMD,EAAG,GAAKlC,EAAG,GAGjBC,GAFKD,EAAG,GAAKD,EAAG,KAENG,GAAOiC,EAAM,GAAK,GAC5B7B,GAFM4B,EAAG,GAAKlC,EAAG,KAELmC,GAAQjC,EAAK,GAAK,GAC9Ba,GAAKd,EAAIkC,EAAM7B,EAAKJ,IAAOA,EAAKiC,GACtC,OAAQC,KAAKC,KAAKpC,GAAKmC,KAAKC,KAAK/B,IAAO8B,KAAKlB,IAAIkB,KAAKE,IAAIrC,GAAImC,KAAKE,IAAIhC,GAAK,GAAM8B,KAAKE,IAAIvB,KAAO,CACpG,CA0GiBwB,CAAMxC,EAAIC,EAAIgC,GACnB3B,OAAWmC,IAANvC,EAAkBH,EAAYC,EAAIC,EAAIM,GAAML,EACjDwC,EAAUrC,EAAOL,EAAIC,EAAIK,EAAIC,EAAIC,GAEvC,OADAN,EAAIK,EACG,GAAP,OAAUyB,EAAG,YAAIU,GAEnB,OAAOV,IACN,KAAF,OAAON,EAAI,YAAIC,EAAI,cAAMD,EAAI,YAAIF,EAAM,cAAMD,EAAM,YAAIC,IAGlDmB,EAAOzB,EAAKA,EAAKG,OAAS,GAC1BuB,EAAMvC,EAAOJ,EAAI0C,EAAMzC,EAAGH,EAAYE,EAAI0C,EAAMzC,GAAIM,GAC1D,MAAO,GAAP,OAAUsB,EAAQ,YAAIc,EAAG,cAAMhB,EAAI,YAAID,EAAI,KAC7C,CC3IA,ICWakB,GAAK,qBAAAC,EAAAA,EAAAA,GAAAA,EAAAA,GAAA,+GAiKRC,EAAAA,QAAU,iBAAH,QAAoBC,EAAAA,EAAAA,MAE3BD,EAAAA,gBAAiBE,EAAAA,EAAAA,GAAe,UAAU,kBAAMC,EAAAA,EAAAA,KAAY,UAAK,WAxJ9C,+IA0B3B,WAAiB,MACI,QAAnB,EAAAC,KAAKC,sBAAc,OAAnBC,EAAqBC,QAAQH,KAAKI,MACnC,CAAAC,IAAAA,uBAAAC,MAED,WAAoB,MACC,QAAnB,EAAAN,KAAKC,sBAAc,OAAnBM,EAAqBC,eACtB,CAAAH,IAAAA,SAAAC,MAED,WACE,IAAQvC,EAA+DiC,KAA/DjC,KAAM0C,EAAyDT,KAAzDS,WAAYL,EAA6CJ,KAA7CI,GAAIM,EAAyCV,KAAzCU,aAAcC,EAA2BX,KAA3BW,aAAc3C,EAAagC,KAAbhC,IAAKC,EAAQ+B,KAAR/B,IACzD2C,EAAKZ,KAAKa,QACMC,EAA+BV,EAA7CW,aAAmCC,EAAUZ,EAAvBa,YAG9B,IAAKlD,GAAwB,IAAhBA,EAAKG,OAChB,OACEgD,EAAAA,EAAAA,GAAAA,MAAAA,CAAA,cACc,OACZC,MAAM,MACNL,OAAQA,EACRM,oBAAoB,OACpBC,QAAO,cAASL,EAAK,YAAIF,GACzBE,MAAOA,IAKb,eFQkBjD,GACpB,cAAyBA,EAAK,GAAE,GAAzBK,EAAM,KAAEC,EAAM,KACfL,EAAa,CAACI,EAAQC,GACtBJ,EAAa,CAACG,EAAQC,GAC5B,OAAON,EAAKa,QACV,kBAAGZ,EAAG,EAAHA,IAAKC,EAAG,EAAHA,IAAG,eAAKqD,EAAC,KAAEC,EAAC,WAAO,CACzBvD,IAAK,CAACkB,KAAKlB,IAAIA,EAAI,GAAIsD,GAAIpC,KAAKlB,IAAIA,EAAI,GAAIuD,IAC5CtD,IAAK,CAACiB,KAAKjB,IAAIA,EAAI,GAAIqD,GAAIpC,KAAKjB,IAAIA,EAAI,GAAIsD,IAC7C,GACD,CAAEvD,IAAAA,EAAKC,IAAAA,GAEX,CEnB6CuD,CAAMzD,GAAlC0D,EAAQ,EAAbzD,IAAoB0D,EAAQ,EAAbzD,IAEnB0D,EAAoBF,EACpBG,EAAoBF,GAEpB1D,EAAMyD,EAAS,IAAMzD,EAAMyD,EAAS,MACtCE,EAAa,CAAC3D,EAAK,KAGjBC,EAAMyD,EAAS,IAAMzD,EAAMyD,EAAS,MACtCE,EAAa,CAAC3D,EAAKyD,EAAS,KAG9B,IAAMrE,WFpBgB,GAA6C,IAA3C2D,EAAK,EAALA,MAAOF,EAAM,EAANA,OAAQ9C,EAAG,EAAHA,IAAKC,EAAG,EAAHA,IACxC4D,EAAS5D,EAAI,GAAKD,EAAI,GACtB8D,EAAS7D,EAAI,GAAKD,EAAI,GAC5B,OAAO,SAACc,GAGN,MAAO,EAFKA,EAAM,GAAKd,EAAI,IAAM6D,EAAUb,EACjCF,EAAUhC,EAAM,GAAKgD,EAAUhB,GAG7C,CEYciB,CAAU,CAAE/D,IAAK2D,EAAY1D,IAAK2D,EAAYZ,MAAAA,EAAOF,OAAAA,IAC/D,EAAgBzD,EAAE,CAACsD,EAAciB,EAAW,KAArCI,GAAyCC,EAAAA,EAAAA,GAAAA,EAAAA,GAApC,GACZ,EAAgB5E,EAAE,CAACqD,EAAckB,EAAW,KAArCM,GAAyCC,EAAAA,EAAAA,GAAAA,EAAAA,GAApC,GACNC,EAAWtE,EAAK,CAAEC,KAAAA,EAAMC,IAAKyD,EAAUxD,IAAKyD,EAAUrE,EAAAA,IACtDgF,EAAO5B,EAAa,wBAAH,OAA2BG,EAAE,UAAMtB,EAC1D,OACE4B,EAAAA,EAAAA,GAAAA,MAAAA,CAAA,cACc,OACZC,MAAM,MACNL,OAAQA,EACRM,oBAAoB,OACpBC,QAAO,cAASL,EAAK,YAAIF,GACzBE,MAAOA,GAENP,GACCS,EAAAA,EAAAA,GAAAA,OAAAA,MACEA,EAAAA,EAAAA,GAAAA,iBAAAA,CAAgBN,GAAE,0BAAqBA,GAAMpD,GAAG,IAAI8E,GAAG,IAAI7E,GAAG,IAAI8E,GAAG,KAClE9B,EAAW+B,KAAI,gBAAGC,EAAM,EAANA,OAAQC,EAAK,EAALA,MAAOC,EAAO,EAAPA,QAAO,OACvCzB,EAAAA,EAAAA,GAAAA,OAAAA,CAAMuB,OAAM,UAAc,IAATA,EAAY,KAAG,aAAcC,EAAK,eAAgBC,GAAW,MAIlF,UAEcrD,IAAjBqB,EACC,EACEO,EAAAA,EAAAA,GAAAA,OAAAA,CAAMJ,OAAO,OAAOF,GAAE,UAAKA,EAAE,KAAKI,MAAM,OAAOM,EAAE,KAAKC,EAAE,OACtDL,EAAAA,EAAAA,GAAAA,OAAAA,CACE0B,EAAC,6CAEDZ,EAAQ,EAAC,6BACTA,EAAQ,EAAC,YAAIlB,EAAM,6BACjBA,EAAM,+BAGRuB,KAAK,YAITnB,EAAAA,EAAAA,GAAAA,OAAAA,CAAMJ,OAAO,OAAOF,GAAE,UAAKA,EAAE,KAAKI,MAAM,OAAOM,EAAE,KAAKC,EAAE,OACtDL,EAAAA,EAAAA,GAAAA,OAAAA,CACE0B,EAAC,0BACDZ,EAAQ,EAAC,6BACTE,EAAQ,EAAC,6BACTA,EAAQ,EAAC,YAAIpB,EAAM,2BACnBkB,EAAQ,EAAC,aAAKlB,EAAM,+BAGpBuB,KAAK,YAITnB,EAAAA,EAAAA,GAAAA,OAAAA,CAAMJ,OAAO,OAAOF,GAAE,UAAKA,EAAE,KAAKI,MAAM,OAAOM,EAAE,KAAKC,EAAE,OACtDL,EAAAA,EAAAA,GAAAA,OAAAA,CACE0B,EAAC,8BACGV,EAAQ,EAAC,iCACTlB,EAAK,iCACLA,EAAK,YAAIF,EAAM,+BACfoB,EAAQ,EAAC,aAAKpB,EAAM,uCAGxBuB,KAAK,YAITnB,EAAAA,EAAAA,GAAAA,OAAAA,CAAMC,MAAM,aAAayB,EAAGR,EAAUC,KAAMA,EAAMQ,KAAI,eAAUjC,EAAE,SAClEM,EAAAA,EAAAA,GAAAA,OAAAA,CAAMC,MAAM,wBAAwByB,EAAGR,EAAUC,KAAMA,EAAMQ,KAAI,eAAUjC,EAAE,SAC7EM,EAAAA,EAAAA,GAAAA,OAAAA,CAAMC,MAAM,aAAayB,EAAGR,EAAUC,KAAMA,EAAMQ,KAAI,eAAUjC,EAAE,UAGpEM,EAAAA,EAAAA,GAAAA,OAAAA,CAAMC,MAAM,aAAayB,EAAGR,EAAUC,KAAMA,OAInD,CAAAhC,IAAAA,KAAAyC,IAAAA,6DDlKc,wRCWC,CAAAC,EAAAA,IAAAA,CAAAA,EAAAA,gBAAAA,iSCXX,IAAMC,EACA,YADAA,EAEK,mBAFLA,EAGJ,QAHIA,EAIH,SAJGA,EAKM,mBALNA,EAME,gBANFA,EAOU,0BAPVA,EAQO,uBARPA,EASH,SATGA,EAUC,eAVDA,EAWH,SAXGA,EAYJ,QAZIA,EAaE,gBAbFA,EAcK,kBAdLA,EAeI,kBAfJA,EAgBG,iBAhBHA,EAiBC,eAjBDA,EAkBL,OAlBKA,EAmBC,eAnBDA,EAoBA,cApBAA,EAqBF,mBArBEA,EAsBF,mBAtBEA,EAuBJ,QAvBIA,EAwBJ,QAxBIA,EAyBC,eAzBDA,EA0BE,cC0Bf,SAASC,GAAQ3C,GACf,OAAO4C,MAAMC,QAAQ7C,EACvB,KASa8C,IAAM,qBAAAzD,EAAAA,EAAAA,GAAAA,EAAAA,GAAA,oCA4lByB,+MAvJlCC,EAAAA,cAAgB,SAACyD,GACvB,IAAMC,EAAS1D,EAAK2D,eACpB,aAAQC,EAAU,EAAVA,WAAYvF,EAAG,EAAHA,IAAKD,EAAG,EAAHA,IAAKyF,EAAQ,EAARA,SAAUC,EAAI,EAAJA,KAClCpD,EAAQV,EAAK4D,GACXnD,EAAQgD,EAARhD,IAER,IAAIsD,EAAAA,EAAAA,GAAgBtD,GAClBgD,EAAMO,qBADR,CAKA,IAAIC,EAEJ,GAAY,YAARxD,GAA6B,eAARA,EAEvBwD,EAAavD,EAAQoD,GADGJ,GAAkB,eAARjD,GAAwB,EAAI,QAEzD,GAAY,cAARA,GAA+B,cAARA,EAAqB,CAErDwD,EAAavD,EAAQoD,GADGJ,GAAkB,cAARjD,GAAuB,EAAI,OAE5C,WAARA,EACLoD,IACFI,EAAavD,EAAQmD,GAEN,aAARpD,EACLoD,IACFI,EAAavD,EAAQmD,GAEN,SAARpD,EACTwD,EAAa7F,EACI,QAARqC,IACTwD,EAAa5F,GAGf,IAAI6F,MAAMD,GAAV,CAIAR,EAAMO,iBACN,IAAMG,EAAyBC,OAAOH,EAAWI,SAAQC,EAAAA,EAAAA,GAAcR,KACvE9D,EAAKuE,UAAS,UACXX,EAAiC5D,EAAKwE,MAAML,EAAwBP,QAuFjE5D,EAAAA,WAAmC,QAEnCA,EAAAA,KAAO,kBAAH,QAAqBC,EAAAA,EAAAA,MAgHzBD,EAAAA,YAAc,WACpBA,EAAK4D,WAAa,MAGZ5D,EAAAA,aAAe,SAACyD,GACtB,IAAMgB,EAAQhB,EAAMiB,cACpB1E,EAAK4D,WAAaa,EAAME,aAAa,oBAG/B3E,EAAAA,mBAAqB,SAACyD,GAC5B,IAAMgB,EAAQhB,EAAMiB,cACpB1E,EAAK4E,qBAAqBnB,EAAOgB,EAAME,aAAa,qBAG9C3E,EAAAA,mBAAqB,SAACyD,GAC5BzD,EAAK4E,qBAAqBnB,EAAO,gBA8B3BzD,EAAAA,WAAa,SAACyD,GACpB,IAAIzD,EAAK6E,WAITpB,EAAMO,iBACFhE,EAAK8E,UAAU,CACjB,IAAMpE,EAAQV,EAAKmC,UAAUsB,EAAMsB,SAAWtB,EAAMuB,OACpD,GAAI3B,GAAQrD,EAAKU,QAA4B,gBAAlBV,EAAK8E,SAC9B,GAAI9E,EAAKiF,mBAAqBjF,EAAKkF,mBAAqBlF,EAAKmF,iBAAkB,CAC7E,IAAMC,EAAc1E,EAAQV,EAAKiF,kBAC3BI,EAAc3E,EAAQV,EAAKkF,kBAE/BG,GAAerF,EAAK3B,KACpB+G,GAAepF,EAAK5B,KACpBiH,EAAcD,IAAgBpF,EAAKmF,kBAEnCnF,EAAKuE,SAAS,CACZe,SAAUtF,EAAKwE,MAAMY,EAAa,YAClCG,SAAUvF,EAAKwE,MAAMa,EAAa,mBAItCrF,EAAKiF,kBAAoBvE,EAAQV,EAAKsF,SACtCtF,EAAKkF,kBAAoBlF,EAAKuF,SAAW7E,EACzCV,EAAKmF,iBAAmBnF,EAAKuF,SAAWvF,EAAKsF,cAG/CtF,EAAKuE,UAAS,UAAGvE,EAAK8E,SAA+B9E,EAAKwE,MAAM9D,EAAOV,EAAK8E,cAa1E9E,EAAAA,iBAAmB,SAACyD,IACtBzD,EAAK6E,WAAaW,EAAAA,EAAAA,GAAuB/B,IAI7CzD,EAAKyF,QAAQhC,IAGPzD,EAAAA,QAAU,SAACyD,GACbzD,EAAK6E,WAIT7E,EAAK0F,sBACL1F,EAAK2F,kBAAkBlC,EAAMsB,SACzB/E,EAAK4F,mBAAqB5F,EAAKA,EAAK8E,WACtC9E,EAAK6F,aAEP7F,EAAK8E,SAAW,KAChB9E,EAAK4F,kBAAoB,KACzB5F,EAAKiF,kBAAoB,KACzBjF,EAAKkF,kBAAoB,KACzBlF,EAAKmF,iBAAmB,OA2ClBnF,EAAAA,cAAgB,SAAC8F,GACvB9F,EAAK+F,QAAUD,GAGT9F,EAAAA,cAAgB,SAACQ,GAClBA,IAKS,aADIA,EAAGmE,aAAa,mBACN3E,EAAKgG,UAAYxF,EAAOR,EAAKiG,UAAYzF,IA0V/DR,EAAAA,YAAc,SAACU,GAOrB,OANAwF,EAAAA,EAAAA,oBAA4C,CAC1CC,OAAQnG,EAAKoG,gBACbC,gBAAiBrG,EAAKqG,gBACtBC,YAAatG,EAAKuG,gBAGbL,EAAAA,EAAAA,SAA+BxF,EAAM8F,yBAzqCV,kBAO+B,wCAYzB,kBAGa,6DAoBf,wCAYF,QAGP,8CASA,kDAaK,sEAkBD,cAKC,UAGJ,SAGA,yBAW0C,UAgBlC,sBA8bb,sBAEiB,yBAEC,yBAEA,kBAEL,GAAE,iDA7iB1C,SAAiBC,GACfrG,KAAKsG,eAAiBD,IACvB,CAAAhG,IAAAA,eAAAC,MAgFD,WACEN,KAAKuG,WAAavG,KAAKwG,uBACxB,CAAAnG,IAAAA,eAAAC,MAMD,WACEN,KAAKyG,uBACN,CAAApG,IAAAA,qBAAAC,MAID,WACEN,KAAK0G,sDAcP,YACEC,EAAAA,EAAAA,GAAmB3G,OACnB4G,EAAAA,EAAAA,GAAiB5G,MACjBA,KAAKyG,qBACLzG,KAAK0G,sBACLG,EAAAA,EAAAA,GAAa7G,OACb8G,EAAAA,EAAAA,GAAY9G,QACb,CAAAK,IAAAA,uBAAAC,MAED,YACEyG,EAAAA,EAAAA,GAAsB/G,OACtBgH,EAAAA,EAAAA,GAAgBhH,OAChBiH,EAAAA,EAAAA,GAAejH,OACfkH,EAAAA,EAAAA,GAAoBlH,MACpBA,KAAKsF,wBACN,CAAAjF,IAAAA,oBAAAC,MAED,YACE6G,EAAAA,EAAAA,GAAuBnH,MAClBiD,GAAQjD,KAAKM,SAChBN,KAAKM,MAAQN,KAAKoH,KAAOpH,KAAKqH,eAAerH,KAAKM,OAASN,KAAKoE,MAAMpE,KAAKM,QAE7EN,KAAKsH,eACLtH,KAAKuH,iBAAiBvH,KAAKwH,YAC3BC,EAAAA,EAAAA,GAA4BzH,KAAMA,KAAKM,SACxC,CAAAD,IAAAA,mBAAAC,MAED,YACEoH,EAAAA,EAAAA,GAAmB1H,QACpB,CAAAK,IAAAA,qBAAAC,MAED,WACMN,KAAK2H,eACP3H,KAAK4H,8BAA8B,SAC/B3E,GAAQjD,KAAKM,SACfN,KAAK4H,8BAA8B,YAC7B5H,KAAK6H,UAAY7H,KAAKsG,cAC1BtG,KAAK8H,wCAIX9H,KAAK+H,kCACLC,EAAAA,EAAAA,GAAsBhI,QACvB,CAAAK,IAAAA,SAAAC,MAED,WAAM,MAAA2H,EAAAA,KACErH,EAAKZ,KAAKI,GAAGQ,IAAMZ,KAAKH,KACxBS,EAAQ2C,GAAQjD,KAAKM,OAASN,KAAKmF,SAAWnF,KAAKM,MACnDtC,EAAMgC,KAAKkF,UAAYlF,KAAKhC,IAC5BkK,EAAclI,KAAKmI,oBACnBC,EAAwE,IAA1DpI,KAAKqI,gBAAgBH,EAAclI,KAAKkF,SAAWlH,GACjEsK,EAA4C,IAA9BtI,KAAKqI,gBAAgB/H,GACnCgD,EAAStD,KAAKuD,eACdgF,EAAetF,GAAQjD,KAAKM,OAE5BkI,EAAaxI,KAAKyI,eAAe,OACjCpE,EAAQrE,KAAK0I,YAAY,CAC7BC,KAAMH,EACNI,eAAgBJ,EAAWK,SAAS,aAAe,QAAU,QAC7DP,YAAAA,EACAF,YAAAA,EACA9E,OAAAA,IAGIwF,EAAgB9I,KAAKyI,eAAe,OACpCM,EACJR,GACAvI,KAAK0I,YAAY,CACfC,KAAMG,EACNF,eACEE,EAAcD,SAAS,cAAgBC,EAAcD,SAAS,WAC1D,QACA,QACNP,YAAAA,EACAF,YAAAA,EACA9E,OAAAA,IAGE0F,EAAgBT,EAAe,QAAUvI,KAAKgJ,cAC9CC,EACc,SAAlBD,EACI,CACEE,KAAM,QACNC,MAAO,SAES,QAAlBH,EACE,CACEE,KAAM,GAAF,OAAK5F,EAAS8E,EAAcE,EAAW,KAC3Ca,MAAO,GAAF,OAAK7F,EAASgF,EAAcF,EAAW,MAG9C,CACEc,KAAM,GAAF,OAAK5F,EAAS,IAAMgF,EAAcF,EAAW,KACjDe,MAAO,GAAF,OAAK7F,EAAS8E,EAAc,IAAME,EAAW,MAG5D,OACEpH,EAAAA,EAAAA,GAACkI,EAAAA,GAAI,CAAA/I,IAAAA,2CAACO,GAAIA,EAAIyI,UAAWrJ,KAAKsJ,cAAeC,aAAcvJ,KAAKwJ,mBAC9DtI,EAAAA,EAAAA,GAACuI,EAAAA,EAAoB,CAAApJ,IAAAA,2CAACoE,SAAUzE,KAAKyE,WACnCvD,EAAAA,EAAAA,GAAAA,MAAAA,CAAAb,IAAAA,2CAAA,cACcqJ,EAAAA,EAAAA,GAAa1J,MACzBmB,OAAK,eACF6B,GAAgB,IAAI,SACpBA,EAAqBuF,IAAY,0BACvBvI,KAAK2J,QAAU,GAAI,IAG/B3J,KAAK4J,eACN1I,EAAAA,EAAAA,GAAAA,MAAAA,CAAAb,IAAAA,2CAAKc,MAAO6B,EAAW6G,IAAK7J,KAAK8J,gBAC/B5I,EAAAA,EAAAA,GAAAA,MAAAA,CAAAb,IAAAA,2CACEc,MAAO6B,EACP+G,cAAe/J,KAAKgK,mBACpBC,MAAOhB,KAET/H,EAAAA,EAAAA,GAAAA,MAAAA,CAAAb,IAAAA,2CAAKc,MAAO6B,GACThD,KAAKuG,WAAW/D,KAAI,SAAC0H,GAAI,MAClBC,EAAa,GAAH,OAAmC,IAA7BlC,EAAKI,gBAAgB6B,GAAW,KAElDE,GAAuB,EAE3B,GAAsB,UAAlBpB,GAA+C,QAAlBA,EAC/B,GAAId,EACFkC,EAAcF,GAAQjC,EAAK/C,UAAYgF,GAAQjC,EAAK9C,aAC/C,CACL,IAAMkF,EAA+B,UAAlBrB,EAA4BhL,EAAMsC,EAC/CgK,EAA6B,UAAlBtB,EAA4B1I,EAAQ2H,EAAKhK,IAC1DmM,EAAcF,GAAQG,GAAcH,GAAQI,EAIhD,OACEpJ,EAAAA,EAAAA,GAAAA,OAAAA,CACEC,OAAK,eACF6B,GAAW,IAAI,SACfA,EAAiBoH,GAAW,GAE/BH,MAAO,CACLf,KAAM5F,EAAS,GAAK6G,EACpBhB,MAAO7F,EAAS6G,EAAa,KAG9BlC,EAAKsC,gBAAgBL,UAMhChJ,EAAAA,EAAAA,GAAAA,MAAAA,CAAAb,IAAAA,2CAAKc,MAAO6B,GACT+F,EACA1E,GACDnD,EAAAA,EAAAA,GAACsJ,EAAAA,EAAmB,CAAAnK,IAAAA,2CAACoK,UAAWzK,aAM3C,CAAAK,IAAAA,cAAAC,MAEO,YAYP,MAXCqI,EAAI,EAAJA,KACArF,EAAM,EAANA,OACAsF,EAAc,EAAdA,eACAR,EAAW,EAAXA,YACAE,EAAW,EAAXA,YAQMoC,EAAY/B,EAAKE,SAAS,WAC1B8B,EAAYhC,EAAKE,SAAS,WAC1B+B,EAAajC,EAAKE,SAAS,OAE3BN,EAAetF,GAAQjD,KAAKM,OAC5BA,EAAQsK,EACV5K,KAAKkF,SACLqD,EACEvI,KAAKmF,SACJnF,KAAKM,MACNuK,EAAYD,EAAa,WAAarC,EAAe,WAAa,QAClEuC,EAAYF,EAAa5K,KAAK+K,SAAWxC,EAAevI,KAAKgL,SAAWhL,KAAK+K,SAC7EE,EAAeL,EAAa5K,KAAKkF,SAAW5E,EAC5C4K,EACU,aAAdL,EACI7K,KAAKmL,uBAAuBnL,KAAKkF,SAAU,OAC7B,aAAd2F,EACE7K,KAAKmL,uBAAuBnL,KAAKmF,SAAU,OAC3CnF,KAAKmL,uBAAuB7K,EAAO,SACrC8K,EAAyBR,EAC3B,CAAE1B,KAAM,GAAF,OAAK5F,EAAS,IAAM8E,EAAcA,EAAW,MACnD,CAAEe,MAAO,GAAF,OAAK7F,EAASgF,EAAc,IAAMA,EAAW,MAClD+C,EAAoB,GAAH,OAAMrI,EAAe,YAC1C4H,EAAa5H,EAA0BA,GAGnCsI,EAASZ,EACX,EACExJ,EAAAA,EAAAA,GAAAA,OAAAA,CAAA,cAAkB,OAAOC,MAAOkK,GAC7BH,IAEHhK,EAAAA,EAAAA,GAAAA,OAAAA,CAAA,cAAkB,OAAOC,MAAK,UAAKkK,EAAiB,YAAIrI,IACrDkI,IAEHhK,EAAAA,EAAAA,GAAAA,OAAAA,CAAA,cAAkB,OAAOC,MAAK,UAAKkK,EAAiB,YAAIrI,IACrDkI,IAGL,GAEEK,EAAY,UACbD,EAAM,EACTpK,EAAAA,EAAAA,GAAAA,MAAAA,CAAKC,MAAO6B,IACZ2H,IAAazJ,EAAAA,EAAAA,GAAAA,MAAAA,CAAKC,MAAO6B,MAO3B,MAJuB,UAAnB4F,GACF2C,EAAaC,WAIbtK,EAAAA,EAAAA,GAAAA,MAAAA,CAAA,gBACiBlB,KAAKyE,SAAQ,aAChBqG,EAAS,mBACJ,aAAY,gBACd9K,KAAK/B,IAAG,gBACR+B,KAAKhC,IAAG,gBACRiN,EACf9J,OAAK,eACF6B,GAAY,IAAI,SAChBA,GAAkB4H,IAAU,SAC5B5H,EAAwC,gBAAtBhD,KAAKyL,cAAkCzL,KAAK0E,WAAamG,IAAS,SACpF7H,EAAmB2H,IAAS,SAC5B3H,EAAoB4H,GAAU,GAChC,kBACgBC,EACjBxK,IAAKsI,EACL+C,OAAQ1L,KAAK2L,YACbC,QAAS5L,KAAK6L,aACd9B,cAAe/J,KAAK8L,mBACpBjC,IAAK7J,KAAK+L,cACVC,KAAK,SACL/B,MAAOmB,EACPa,SAAU,GAETV,KAGN,CAAAlL,IAAAA,cAAAC,MAEO,WACN,OAAON,KAAKwH,WACVtG,EAAAA,EAAAA,GAAAA,gBAAAA,CACEC,MAAO6B,EACPvC,WAAYT,KAAKkM,eACjBnO,KAAMiC,KAAKwH,UACX9G,aAAcuC,GAAQjD,KAAKM,OAASN,KAAKmF,SAAWnF,KAAKM,MACzDK,aAAcsC,GAAQjD,KAAKM,OAASN,KAAKkF,SAAWlF,KAAKhC,IACzDC,IAAK+B,KAAK/B,IACVD,IAAKgC,KAAKhC,MAEV,OACL,CAAAqC,IAAAA,kBAAAC,MAEO,SAAgB4J,GAAY,MAC1B5D,EAAqEtG,KAArEsG,aAAcqB,EAAuD3H,KAAvD2H,aAAcwE,EAAyCnM,KAAzCmM,WAAYlO,EAA6B+B,KAA7B/B,IAAKD,EAAwBgC,KAAxBhC,IAAK6J,EAAmB7H,KAAnB6H,QACpDU,EAAetF,GADwDjD,KAAVM,OAE7D8L,EAAiBlC,IAASlM,EAC1BqO,EAAiBnC,IAASjM,EAC1BqO,EAAWF,GAAkBC,EAOnC,OAJEF,KACG7F,IAAiBgG,IAAazE,IAAYU,IAC1CjC,IAAiBgG,IAAczE,IAAYF,KAG9CzG,EAAAA,EAAAA,GAAAA,OAAAA,CACEC,OAAK,eACF6B,GAAgB,IAAI,SACpBA,EAAcoJ,IAAc,SAC5BpJ,EAAcqJ,GAAc,IAG9BrM,KAAKmL,uBAAuBjB,EAAM,SAEnC,OACL,CAAA7J,IAAAA,qBAAAC,MAoDD,SAAmB+C,GACjB,IAAIrD,KAAKyE,WAAaW,EAAAA,EAAAA,GAAuB/B,GAA7C,CAIA,IAAM/B,EAAI+B,EAAMsB,SAAWtB,EAAMuB,MAC3B2H,EAAWvM,KAAK+B,UAAUT,GAC5BkL,EAA6B,QACjC,GAAIvJ,GAAQjD,KAAKM,OAEf,GADgBiM,GAAYvM,KAAKkF,UAAYqH,GAAYvM,KAAKmF,UACzB,gBAAtBnF,KAAKyL,aAClBe,EAAO,mBAGPA,EADoBtN,KAAKE,IAAIY,KAAKmF,SAAWoH,GAAYrN,KAAKE,IAAIY,KAAKkF,SAAWqH,IAC5DA,GAAYvM,KAAKmF,SAAW,WAAa,WAGnEnF,KAAKwF,kBAAoBxF,KAAKwM,GAC9BxM,KAAKyM,UAAUD,GACOxM,KAAKI,GAAGsM,WAAWC,cAAc,IAAD,OAAK3J,EAAS,aAElEhD,KAAKmE,UAAS,UAAGqI,EAA2BxM,KAAKoE,MAAMmI,EAAUC,KAEnExM,KAAKuF,kBAAkBjE,MACxB,CAAAjB,IAAAA,mBAAAC,MAED,SAAiB+C,GAEfA,EAAMO,kFAiCR,gGAAAgJ,EAAAA,KAAAA,GACQC,EAAAA,EAAAA,GAAmB7M,MAAK,OAGxB,QADA8M,EAAS9M,KAAK4F,UAAY5F,KAAK4F,UAAY5F,KAAK6F,iBAChD,IAANiH,GAAAA,EAAQC,QAAQ,gDACjB,kFAgDO,SAAepE,GACrB,IAAMqE,EAA2B,CAACrE,GAclC,OAZI3I,KAAK2H,cACPqF,EAAeC,KAAK,WAGlBjN,KAAK6H,SACPmF,EAAeC,KAAK,WAGlBjN,KAAKsG,cACP0G,EAAeC,KAAK,aAGfD,EAAerP,KAAK,OAC5B,CAAA0C,IAAAA,qBAAAC,MAED,WACE,IAAQ4E,EAAuBlF,KAAvBkF,SAAUC,EAAanF,KAAbmF,SAEM,kBAAbD,GAA6C,kBAAbC,IACzCnF,KAAKM,MAAQ,CAAC4E,EAAUC,MAE3B,CAAA9E,IAAAA,qBAAAC,MAED,WACE,IAAQA,EAAUN,KAAVM,MAEJ2C,GAAQ3C,KACVN,KAAKkF,SAAW5E,EAAM,GACtBN,KAAKmF,SAAW7E,EAAM,MAEzB,CAAAD,IAAAA,eAAAC,MAED,WACEN,KAAKkN,aACN,CAAA7M,IAAAA,eAAAC,MAEO,WACN,OAAON,KAAKmN,WAAanN,KAAKsG,eAC/B,CAAAjG,IAAAA,oBAAAC,MAEO,WACN,QAAK2C,GAAQjD,KAAKM,SAIfN,KAAKsG,cAAkC,IAAlBtG,KAAKmF,WAAqBnF,KAAKsG,cAAkC,IAAlBtG,KAAKkF,YAE7E,CAAA7E,IAAAA,iBAAAC,MAEO,WACN,IAAM8M,GAAWpN,KAAK/B,IAAM+B,KAAKhC,KAAOgC,KAAKqN,MD3rBV,IC6rBnC,OAAOD,EAAU,EAAI,EAAIA,IAC1B,CAAA/M,IAAAA,qBAAAC,MAEO,WAAkB,MAClBgN,EAAyB,QAAb,EAAGtN,KAAKqN,aAAK,QAAI,EAEnC,GAAIC,GAAgB,EAClB,MAAO,GAQT,IALA,IAAMD,EAAkB,CAACrN,KAAKhC,KAExBmM,EAAamD,EADHtN,KAAKuN,iBAEjBC,EAAUxN,KAAKhC,IAEZwP,EAAUxN,KAAK/B,KACpBuP,GAAWrD,EACXkD,EAAMJ,KAAK/N,KAAKlB,IAAIwP,EAASxN,KAAK/B,MAOpC,OAJKoP,EAAMxE,SAAS7I,KAAK/B,MACvBoP,EAAMJ,KAAKjN,KAAK/B,KAGXoP,IACR,CAAAhN,IAAAA,uBAAAC,MAoBO,SAAqB+C,EAAqBmJ,IAC3CpH,EAAAA,EAAAA,GAAuB/B,IAI5BrD,KAAKyM,UAAUD,KAChB,CAAAnM,IAAAA,YAAAC,MAEO,SAAUkM,GAChBxM,KAAK0E,SAAW8H,EAChBxM,KAAKyL,aAAezL,KAAK0E,SACzB1E,KAAKwD,WAAagJ,EAClBiB,OAAOC,iBAAiB,cAAe1N,KAAK2N,YAC5CF,OAAOC,iBAAiB,YAAa1N,KAAK4N,kBAC1CH,OAAOC,iBAAiB,gBAAiB1N,KAAKqF,WAC/C,CAAAhF,IAAAA,oBAAAC,MAEO,SAAkBuN,GACF,aAAlB7N,KAAK0E,SACP1E,KAAK4F,UAAUmH,QACY,aAAlB/M,KAAK0E,UAA6C,UAAlB1E,KAAK0E,SAC9C1E,KAAK6F,UAAUkH,QACY,gBAAlB/M,KAAK0E,UACd1E,KAAK8N,iBAAiBD,GAAQd,UAEjC,CAAA1M,IAAAA,YAAAC,MAmCO,WACNN,KAAK+N,mBAAmBC,SACzB,CAAA3N,IAAAA,aAAAC,MAEO,WACNN,KAAKiO,oBAAoBD,SAC1B,CAAA3N,IAAAA,sBAAAC,MA2BO,WACNmN,OAAOS,oBAAoB,cAAelO,KAAK2N,YAC/CF,OAAOS,oBAAoB,YAAalO,KAAK4N,kBAC7CH,OAAOS,oBAAoB,gBAAiBlO,KAAKqF,iCAQ3C,SACN8I,GAEE,IAEEC,EAFF,QAIFC,OAAOC,KAAKH,GAAQI,SAAQ,SAACC,GAC3B,IAAMC,EAAWN,EAAOK,GAExB,IAAKJ,EAAc,CACjB,IAAMM,EAAWC,EAAKH,GACtBJ,EAAeM,IAAaD,EAG9BE,EAAKH,GAAYC,KAGdL,KAIYpO,KAAK0E,UAEpB1E,KAAKyF,aAEPzF,KAAK4O,kCAuBC,SAAMtO,EAAekM,GAW3B,OAVAlM,GAAQ8D,EAAAA,EAAAA,GAAM9D,EAAON,KAAKhC,IAAKgC,KAAK/B,KAGvB,aAATuO,IACFlM,EAAQpB,KAAKjB,IAAIqC,EAAON,KAAKkF,WAElB,aAATsH,IACFlM,EAAQpB,KAAKlB,IAAIsC,EAAON,KAAKmF,WAGxB7E,2BASD,SAAUgB,GAChB,IAAME,EAAQxB,KAAK/B,IAAM+B,KAAKhC,IAC9B,EAAwBgC,KAAK2F,QAAQkJ,wBAC/BC,GAAWxN,EADL,EAAJ4H,MAAW,EAALlI,MAERsC,EAAStD,KAAKuD,eACdwL,EAAe/O,KAAKoE,MAAMpE,KAAKhC,IAAMwD,GAAS8B,EAAS,EAAIwL,EAAUA,IACrExO,EAAQ0D,OAAO+K,EAAa9K,SAAQC,EAAAA,EAAAA,GAAclE,KAAK0D,QAE7D,OAAS1D,KAAKoH,MAAQpH,KAAK0D,KAAgB1D,KAAKqH,eAAe/G,GAA5BA,gCAS7B,SAAeA,GACrB,IAAQrC,EAAmB+B,KAAnB/B,IAAKD,EAAcgC,KAAdhC,IAAK0F,EAAS1D,KAAT0D,KAGZsL,EAAmB,IAAIC,EAAAA,EAAW,GAAD,OAAI/P,KAAKgQ,OAAO5O,EAAQtC,GAAO0F,KACnEyL,SAAS,GAAD,OAAIzL,IACZ0L,IAAI,GAAD,OAAIpR,IACPoI,WAECiJ,EAAerP,KAAKoE,MAAMJ,OAAOgL,IAMrC,OAJIK,EAAepR,IACjBoR,GAAgB3L,GAGX2L,IACR,CAAAhP,IAAAA,mBAAAC,MAEO,SAAiBuN,GACvB,OAAO7N,KAAKsP,aAAatP,KAAK6F,UAAWgI,GAAU7N,KAAKsP,aAAatP,KAAK4F,UAAWiI,GACjF7N,KAAK4F,UACL5F,KAAK6F,YACV,CAAAxF,IAAAA,eAAAC,MAEO,SAAaF,EAAoByN,GACvC,OAAO3O,KAAKE,IAAIgB,EAAGyO,wBAAwB3F,KAAO2E,KACnD,CAAAxN,IAAAA,wBAAAC,MAEO,SAAsBiP,GAC5B,OAAOvL,OAAOyJ,OAAO+B,iBAAiBD,GAASE,iBAAiB,aAAaC,MAAM,OAAO,mCAUpF,SAAgBC,GACtBA,EAAM3P,KAAKoE,MAAMuL,GACjB,IAAMnO,EAAQxB,KAAK/B,IAAM+B,KAAKhC,IAC9B,OAAQ2R,EAAM3P,KAAKhC,KAAOwD,IAC3B,CAAAnB,IAAAA,gCAAAC,MAEO,SAA8BsP,GACpC,IAAMC,EAAyB7P,KAAKI,GAAGsM,WAAWC,cAAc,mBAAD,OAAoBiD,IAC7EE,EAA+B9P,KAAKI,GAAGsM,WAAWC,cAAc,mBAAD,OAChDiD,EAAI,YAEnBG,EAAoC/P,KAAKI,GAAGsM,WAAWC,cAAc,mBAAD,OACrDiD,EAAI,iBAEnBI,EAAoBF,EAAYjB,wBAChCoB,EAAoBjQ,KAAKkQ,cAAcF,EAAkB9G,KAAM8G,EAAkB7G,OACvF0G,EAAM5F,MAAMkG,UAAY,cAAH,OAAiBF,EAAiB,OACvDF,EAAiB9F,MAAMkG,UAAY,cAAH,OAAiBF,EAAiB,SACnE,CAAA5P,IAAAA,sCAAAC,MAEO,WACN,IAAQoM,EAAe1M,KAAKI,GAApBsM,WAEFpJ,EAAStD,KAAKuD,eACd6M,EAAe9M,EAAS,QAAU,WAClC+M,EAAgB/M,EAAS,WAAa,QAEtCgN,EAAkC5D,EAAWC,cAAc,mBAAD,OAC3CyD,IAEfG,EAAwC7D,EAAWC,cAAc,mBAAD,OACjDyD,EAAY,YAE3BI,EAA6C9D,EAAWC,cAAc,mBAAD,OACtDyD,EAAY,iBAE3BK,EAAiCzQ,KAAKkQ,cAC1CK,EAAqB1B,wBAAwB3F,KAC7CqH,EAAqB1B,wBAAwB1F,OAGzCuH,EAAmChE,EAAWC,cAAc,mBAAD,OAC5C0D,IAEfM,EAAyCjE,EAAWC,cAAc,mBAAD,OAClD0D,EAAa,YAE5BO,EAA8ClE,EAAWC,cAAc,mBAAD,OACvD0D,EAAa,iBAE5BQ,EAAkC7Q,KAAKkQ,cAC3CS,EAAsB9B,wBAAwB3F,KAC9CyH,EAAsB9B,wBAAwB1F,OAG1C2H,EAAgB9Q,KAAK+Q,sBAAsBT,GAC3CU,EAA0BhR,KAAKiR,qBACnCT,EACAI,GAGIM,EAAcZ,EACda,EAAcL,EAAgB,EAEpC,GAAIE,EAA0B,GAE5B,GADAE,EAAYE,UAAUhC,IAAIpM,EAAYA,GACE,IAApC6N,GAA4E,IAAnCJ,EAAsC,CAEjF,IAAIY,EAA0BL,EAA0B,EAAIG,EAC5DE,GAC0C,IAAxCnS,KAAKC,KAAKkS,GACNnS,KAAKE,IAAIiS,IACRA,EAEP,IAAMC,EAAsCtR,KAAKkQ,cAC/CM,EAA0B3B,wBAAwB3F,KAChDmI,EACAF,EACFX,EAA0B3B,wBAAwB1F,MAChDkI,EACAF,GAGAI,EAA2BP,EAA0B,EACnDQ,EAAuCxR,KAAKkQ,cAChDU,EAA2B/B,wBAAwB3F,KAAOqI,EAC1DX,EAA2B/B,wBAAwB1F,MAAQoI,GAGjB,IAAxCD,IACFD,GAA2BC,EAC3BC,GAA4BD,GAGe,IAAzCE,IACFH,GAA2BG,EAC3BD,GAA4BC,GAG9BlB,EAAerG,MAAMkG,UAAY,cAAH,OAAiBkB,EAAuB,OACtEb,EAA0BvG,MAAMkG,UAAY,cAAH,OACvCkB,EAA0BF,EAC5B,OACAT,EAAgBzG,MAAMkG,UAAY,cAAH,OAAiBoB,EAAwB,OACxEX,EAA2B3G,MAAMkG,UAAY,cAAH,OAAiBoB,EAAwB,YAC9E,GAAId,EAAiC,GAAKI,EAAkC,EAEjFP,EAAerG,MAAMkG,UAAY,cAAH,OAC5BM,EAAiCU,EACnC,OACAT,EAAgBzG,MAAMkG,UAAY,cAAH,OAC7Ba,EAA0BH,EAC5B,OACAD,EAA2B3G,MAAMkG,UAAY,cAAH,OACxCa,EAA0BH,EAC5B,YACK,GAAIJ,EAAiC,GAAKI,EAAkC,EAAG,CAEpF,IAAIQ,EACFnS,KAAKE,IAAIqR,GAAkCO,EAA0BG,EACvEE,GAC0C,IAAxCnS,KAAKC,KAAKkS,GACNnS,KAAKE,IAAIiS,IACRA,EACPf,EAAerG,MAAMkG,UAAY,cAAH,OAAiBkB,EAAuB,OACtEb,EAA0BvG,MAAMkG,UAAY,cAAH,OACvCkB,EAA0BF,EAC5B,aAGFD,EAAYE,UAAUK,OAAOzO,EAAYA,GACzCsN,EAAerG,MAAMkG,UAAY,cAAH,OAAiBM,EAA8B,OAC7ED,EAA0BvG,MAAMkG,UAAY,cAAH,OAAiBM,EAA8B,OACxFC,EAAgBzG,MAAMkG,UAAY,cAAH,OAAiBU,EAA+B,OAC/ED,EAA2B3G,MAAMkG,UAAY,cAAH,OAAiBU,EAA+B,qDAOtF,WACN,IAAMtI,EAAetF,GAAQjD,KAAKM,OAClC,IAAKN,KAAKsG,cAAiBiC,GAAiBvI,KAAK2H,cAAiB3H,KAAK6H,WAGlE7H,KAAKsG,cAAiBiC,IAAgBvI,KAAK2H,cAAiB3H,KAAK6H,WAGjE7H,KAAKsG,cAAiBiC,GAAiBvI,KAAK2H,eAAgB3H,KAAK6H,WAGjE7H,KAAKsG,cAAiBiC,IAAgBvI,KAAK2H,eAAgB3H,KAAK6H,WAGhE7H,KAAKsG,eAAgBiC,GAAiBvI,KAAK6H,YAG5C7H,KAAKsG,cAAiBtG,KAAK6H,SAAY7H,KAAK2H,cAAhD,CAIA,IAAM/B,EAAmC5F,KAAKI,GAAGsM,WAAWC,cAAc,IAAD,OACnE3J,IAEA6C,EAAmC7F,KAAKI,GAAGsM,WAAWC,cAAc,IAAD,OAAK3J,IAExE0O,EAAuC1R,KAAKI,GAAGsM,WAAWC,cAAc,IAAD,OACvE3J,IAEA2O,EAAuC3R,KAAKI,GAAGsM,WAAWC,cAAc,IAAD,OACvE3J,KAGD4C,GAAaC,GAAa6L,GAAgBC,IAC7CD,EAAazH,MAAMtH,QAAU3C,KAAK4R,uBAAuBF,EAAc7L,GAAa,IAAM,IAC1F8L,EAAa1H,MAAMtH,QAAU3C,KAAK6R,uBAAuBF,EAAc9L,GAAa,IAAM,KAGxFD,GAAaC,GAAa6L,GAAgBC,IAC5CD,EAAazH,MAAMtH,QACjB3C,KAAK4R,uBAAuBF,EAAc9L,IAC1C5F,KAAK4R,uBAAuBF,EAAc7L,GACtC,IACA,IACN8L,EAAa1H,MAAMtH,QACjB3C,KAAK6R,uBAAuBF,EAAc/L,IACzC5F,KAAK6R,uBAAuBF,EAAc9L,IAAc7F,KAAKsG,aAC1D,IACA,mCAWF,SAAcwL,EAAoBC,GACxC,IAAMC,EAAahS,KAAKI,GAAGyO,wBAG3B,OAAIiD,EAFW,EAEWE,EAAW9I,KAC5B8I,EAAW9I,KAAO4I,EAHZ,EAMXC,EANW,EAMYC,EAAW7I,MANvB,GAOJ4I,EAAcC,EAAW7I,OAG7B,sCAUD,SAAqB8I,EAA4BC,GACvD,IAAMC,EAAkBF,EAAUpD,wBAC5BuD,EAAmBF,EAAWrD,wBAC9BwD,EAAoBrS,KAAK+Q,sBAAsBkB,GAC/CK,EAAoBH,EAAgBhJ,MAAQkJ,EAAoBD,EAAiBlJ,KAEvF,OAAOhK,KAAKjB,IAAIqU,EAAmB,yCAS7B,SAAuBvH,EAA2B+B,GACxD,IAAMyF,EAAiBxH,EAAS8D,wBAC1B2D,EAAe1F,EAAO+B,wBAC5B,OAAO4D,EAAAA,EAAAA,GAAWF,EAAgBC,yCAS5B,SAAuBxH,EAA2B8B,GACxD,IAAM4F,EAAiB1H,EAAS6D,wBAC1B2D,EAAe1F,EAAO+B,wBAC5B,OAAO4D,EAAAA,EAAAA,GAAWC,EAAgBF,KACnC,CAAAnS,IAAAA,yBAAAC,MAiBO,SAAuBA,EAAeqI,GAC5C,IAAMgK,EAAkB3S,KAAK4S,eAE7B,IAAKD,EACH,OAAO3S,KAAK6S,YAAYvS,GAG1B,IAAMwS,EAAiBH,EAAgBrS,EAAOqI,EAAM3I,KAAK6S,aAEzD,OAAsB,MAAlBC,EACK9S,KAAK6S,YAAYvS,GAGnBwS,IACR,CAAAzS,IAAAA,KAAAyC,IAAAA,mSCxwCe,skSD+DC,CAAAC,EAAAA,IAAAA,CAAAA,GAAAA,iBAAAA,8wCE/DNqB,EAAQ,SAAC9D,EAAetC,EAAaC,GAAW,OAAaiB,KAAKjB,IAAID,EAAKkB,KAAKlB,IAAIsC,EAAOrC,GAAI,EAEtG8U,EAAqB,IAAIC,OAAO,oCAWzB9O,EAAgB,SAAC5D,GAC5B,IAAMoP,GAAS,GAAKpP,GAAOoP,MAAMqD,GACjC,OAAKrD,GAAgC,IAAvBuD,SAASvD,EAAM,IAGtBxQ,KAAKjB,IACV,GAECyR,EAAM,GAAKA,EAAM,GAAGxR,OAAS,IAE3BwR,EAAM,IAAMA,EAAM,GAAK,IAPnB,CASX,WAEgBwD,EAAY5S,GAC1B,OAAI4D,EAAc5D,GAAS,GAAKA,EAAQ,EAC/B6S,WAAW,KAAD,OAAM7S,EAAM8F,WAAWgN,MAAM,KAAK,KAE9C9S,CACT,UAEgB+S,EAAM/S,EAAegT,EAAiBC,EAAiBC,EAAeC,GACpF,OAASnT,EAAQgT,IAAYG,EAAQD,IAAWD,EAAUD,GAAWE,CACvE,UAUgBE,EAAiBpT,EAAekB,EAAemS,GAC7D,OAAOrT,EAAQqT,GAAa,EAAIrT,EAAQkB,EAAQmS,EAAY,EAAI,CAClE","sources":["../node_modules/@esri/calcite-components/dist/components/src/components/graph/util.ts","../node_modules/@esri/calcite-components/dist/components/src/components/graph/graph.scss?tag=calcite-graph&encapsulation=shadow","../node_modules/@esri/calcite-components/dist/components/src/components/graph/graph.tsx","../node_modules/@esri/calcite-components/dist/components/src/components/slider/resources.ts","../node_modules/@esri/calcite-components/dist/components/src/components/slider/slider.tsx","../node_modules/@esri/calcite-components/dist/components/src/components/slider/slider.scss?tag=calcite-slider&encapsulation=shadow","../node_modules/@esri/calcite-components/dist/components/src/utils/math.ts"],"sourcesContent":["import { DataSeries, Extent, Graph, Point, TranslateOptions, Translator } from \"../graph/interfaces\";\n\n/**\n * Calculate slope of the tangents\n * uses Steffen interpolation as it's monotonic\n * http://jrwalsh1.github.io/posts/interpolations/\n *\n * @param p0\n * @param p1\n * @param p2\n */\nfunction slope(p0: Point, p1: Point, p2: Point): number {\n  const dx = p1[0] - p0[0];\n  const dx1 = p2[0] - p1[0];\n  const dy = p1[1] - p0[1];\n  const dy1 = p2[1] - p1[1];\n  const m = dy / (dx || (dx1 < 0 && 0));\n  const m1 = dy1 / (dx1 || (dx < 0 && 0));\n  const p = (m * dx1 + m1 * dx) / (dx + dx1);\n  return (Math.sign(m) + Math.sign(m1)) * Math.min(Math.abs(m), Math.abs(m1), 0.5 * Math.abs(p)) || 0;\n}\n\n/**\n * Calculate slope for just one tangent (single-sided)\n *\n * @param p0\n * @param p1\n * @param m\n */\nfunction slopeSingle(p0: Point, p1: Point, m: number): number {\n  const dx = p1[0] - p0[0];\n  const dy = p1[1] - p0[1];\n  return dx ? ((3 * dy) / dx - m) / 2 : m;\n}\n\n/**\n * Given two points and their tangent slopes,\n * calculate the bezier handle coordinates and return draw command.\n *\n * Translates Hermite Spline to Bézier curve:\n * https://stackoverflow.com/questions/42574940/\n *\n * @param p0\n * @param p1\n * @param m0\n * @param m1\n * @param t\n */\nfunction bezier(p0: Point, p1: Point, m0: number, m1: number, t: Translator): string {\n  const [x0, y0] = p0;\n  const [x1, y1] = p1;\n  const dx = (x1 - x0) / 3;\n  const h1 = t([x0 + dx, y0 + dx * m0]).join(\",\");\n  const h2 = t([x1 - dx, y1 - dx * m1]).join(\",\");\n  const p = t([x1, y1]).join(\",\");\n  return `C ${h1} ${h2} ${p}`;\n}\n\n/**\n * Generate a function which will translate a point\n * from the data coordinate space to svg viewbox oriented pixels\n *\n * @param root0\n * @param root0.width\n * @param root0.height\n * @param root0.min\n * @param root0.max\n */\nexport function translate({ width, height, min, max }: TranslateOptions): Translator {\n  const rangeX = max[0] - min[0];\n  const rangeY = max[1] - min[1];\n  return (point) => {\n    const x = ((point[0] - min[0]) / rangeX) * width;\n    const y = height - (point[1] / rangeY) * height;\n    return [x, y];\n  };\n}\n\n/**\n * Get the min and max values from the dataset\n *\n * @param data\n */\nexport function range(data: DataSeries): Extent {\n  const [startX, startY] = data[0];\n  const min: Point = [startX, startY];\n  const max: Point = [startX, startY];\n  return data.reduce(\n    ({ min, max }, [x, y]) => ({\n      min: [Math.min(min[0], x), Math.min(min[1], y)],\n      max: [Math.max(max[0], x), Math.max(max[1], y)],\n    }),\n    { min, max },\n  );\n}\n\n/**\n * Generate drawing commands for an area graph\n * returns a string can can be passed directly to a path element's `d` attribute\n *\n * @param root0\n * @param root0.data\n * @param root0.min\n * @param root0.max\n * @param root0.t\n */\nexport function area({ data, min, max, t }: Graph): string {\n  if (data.length === 0) {\n    return \"\";\n  }\n\n  // important points for beginning and ending the path\n  const [startX, startY] = t(data[0]);\n  const [minX, minY] = t(min);\n  const [maxX] = t(max);\n\n  // keep track of previous slope/points\n  let m: number;\n  let p0: Point;\n  let p1: Point;\n\n  // iterate over data points, calculating command for each\n  const commands = data.reduce((acc, point, i) => {\n    p0 = data[i - 2];\n    p1 = data[i - 1];\n    if (i > 1) {\n      const m1 = slope(p0, p1, point);\n      const m0 = m === undefined ? slopeSingle(p0, p1, m1) : m;\n      const command = bezier(p0, p1, m0, m1, t);\n      m = m1;\n      return `${acc} ${command}`;\n    }\n    return acc;\n  }, `M ${minX},${minY} L ${minX},${startY} L ${startX},${startY}`);\n\n  // close the path\n  const last = data[data.length - 1];\n  const end = bezier(p1, last, m, slopeSingle(p1, last, m), t);\n  return `${commands} ${end} L ${maxX},${minY} Z`;\n}\n",":host {\n  @apply block;\n  block-size: 100%;\n}\n\n.svg {\n  fill: currentColor;\n  stroke: transparent;\n  @apply m-0 block h-full w-full p-0;\n\n  .graph-path--highlight {\n    fill: var(--calcite-color-brand);\n    @apply opacity-50;\n  }\n}\n\n@include base-component();\n","import { Component, Element, forceUpdate, h, Prop, VNode } from \"@stencil/core\";\nimport { guid } from \"../../utils/guid\";\nimport { createObserver } from \"../../utils/observers\";\nimport { ColorStop, DataSeries, Point } from \"./interfaces\";\nimport { area, range, translate } from \"./util\";\n\n@Component({\n  tag: \"calcite-graph\",\n  styleUrl: \"graph.scss\",\n  shadow: true,\n})\nexport class Graph {\n  //--------------------------------------------------------------------------\n  //\n  //  Properties\n  //\n  //--------------------------------------------------------------------------\n\n  /**\n   * Array of tuples describing a single data point ([x, y])\n   * These data points should be sorted by x-axis value.\n   */\n  @Prop() data: DataSeries = [];\n\n  /**\n   * Array of values describing a single color stop ([offset, color, opacity])\n   * These color stops should be sorted by offset value.\n   */\n  @Prop() colorStops: ColorStop[];\n\n  /** Start of highlight color if highlighting range. */\n  @Prop() highlightMin: number;\n\n  /** End of highlight color if highlighting range. */\n  @Prop() highlightMax: number;\n\n  /** Lowest point of the range. */\n  @Prop({ reflect: true }) min!: number;\n\n  /** Highest point of the range. */\n  @Prop({ reflect: true }) max!: number;\n\n  //--------------------------------------------------------------------------\n  //\n  //  Lifecycle\n  //\n  //--------------------------------------------------------------------------\n\n  connectedCallback(): void {\n    this.resizeObserver?.observe(this.el);\n  }\n\n  disconnectedCallback(): void {\n    this.resizeObserver?.disconnect();\n  }\n\n  render(): VNode {\n    const { data, colorStops, el, highlightMax, highlightMin, min, max } = this;\n    const id = this.graphId;\n    const { clientHeight: height, clientWidth: width } = el;\n\n    // if we have no data, return empty svg\n    if (!data || data.length === 0) {\n      return (\n        <svg\n          aria-hidden=\"true\"\n          class=\"svg\"\n          height={height}\n          preserveAspectRatio=\"none\"\n          viewBox={`0 0 ${width} ${height}`}\n          width={width}\n        />\n      );\n    }\n\n    const { min: rangeMin, max: rangeMax } = range(data);\n\n    let currentMin: Point = rangeMin;\n    let currentMax: Point = rangeMax;\n\n    if (min < rangeMin[0] || min > rangeMin[0]) {\n      currentMin = [min, 0];\n    }\n\n    if (max > rangeMax[0] || max < rangeMax[0]) {\n      currentMax = [max, rangeMax[1]];\n    }\n\n    const t = translate({ min: currentMin, max: currentMax, width, height });\n    const [hMinX] = t([highlightMin, currentMax[1]]);\n    const [hMaxX] = t([highlightMax, currentMax[1]]);\n    const areaPath = area({ data, min: rangeMin, max: rangeMax, t });\n    const fill = colorStops ? `url(#linear-gradient-${id})` : undefined;\n    return (\n      <svg\n        aria-hidden=\"true\"\n        class=\"svg\"\n        height={height}\n        preserveAspectRatio=\"none\"\n        viewBox={`0 0 ${width} ${height}`}\n        width={width}\n      >\n        {colorStops ? (\n          <defs>\n            <linearGradient id={`linear-gradient-${id}`} x1=\"0\" x2=\"1\" y1=\"0\" y2=\"0\">\n              {colorStops.map(({ offset, color, opacity }) => (\n                <stop offset={`${offset * 100}%`} stop-color={color} stop-opacity={opacity} />\n              ))}\n            </linearGradient>\n          </defs>\n        ) : null}\n\n        {highlightMin !== undefined ? (\n          [\n            <mask height=\"100%\" id={`${id}1`} width=\"100%\" x=\"0%\" y=\"0%\">\n              <path\n                d={`\n            M 0,0\n            L ${hMinX - 1},0\n            L ${hMinX - 1},${height}\n            L 0,${height}\n            Z\n          `}\n                fill=\"white\"\n              />\n            </mask>,\n\n            <mask height=\"100%\" id={`${id}2`} width=\"100%\" x=\"0%\" y=\"0%\">\n              <path\n                d={`\n            M ${hMinX + 1},0\n            L ${hMaxX - 1},0\n            L ${hMaxX - 1},${height}\n            L ${hMinX + 1}, ${height}\n            Z\n          `}\n                fill=\"white\"\n              />\n            </mask>,\n\n            <mask height=\"100%\" id={`${id}3`} width=\"100%\" x=\"0%\" y=\"0%\">\n              <path\n                d={`\n                M ${hMaxX + 1},0\n                L ${width},0\n                L ${width},${height}\n                L ${hMaxX + 1}, ${height}\n                Z\n              `}\n                fill=\"white\"\n              />\n            </mask>,\n\n            <path class=\"graph-path\" d={areaPath} fill={fill} mask={`url(#${id}1)`} />,\n            <path class=\"graph-path--highlight\" d={areaPath} fill={fill} mask={`url(#${id}2)`} />,\n            <path class=\"graph-path\" d={areaPath} fill={fill} mask={`url(#${id}3)`} />,\n          ]\n        ) : (\n          <path class=\"graph-path\" d={areaPath} fill={fill} />\n        )}\n      </svg>\n    );\n  }\n\n  //--------------------------------------------------------------------------\n  //\n  //  Private State/Props\n  //\n  //--------------------------------------------------------------------------\n\n  @Element() el: HTMLCalciteGraphElement;\n\n  private graphId = `calcite-graph-${guid()}`;\n\n  private resizeObserver = createObserver(\"resize\", () => forceUpdate(this));\n}\n","export const CSS = {\n  container: \"container\",\n  containerRange: \"container--range\",\n  graph: \"graph\",\n  handle: \"handle\",\n  handleExtension: \"handle-extension\",\n  handleLabel: \"handle__label\",\n  handleLabelMinValue: \"handle__label--minValue\",\n  handleLabelValue: \"handle__label--value\",\n  hyphen: \"hyphen\",\n  hyphenWrap: \"hyphen--wrap\",\n  static: \"static\",\n  thumb: \"thumb\",\n  thumbActive: \"thumb--active\",\n  thumbContainer: \"thumb-container\",\n  thumbMinValue: \"thumb--minValue\",\n  thumbPrecise: \"thumb--precise\",\n  thumbValue: \"thumb--value\",\n  tick: \"tick\",\n  tickActive: \"tick--active\",\n  tickLabel: \"tick__label\",\n  tickMax: \"tick__label--max\",\n  tickMin: \"tick__label--min\",\n  ticks: \"ticks\",\n  track: \"track\",\n  trackRange: \"track__range\",\n  transformed: \"transformed\",\n};\n\nexport const maxTickElementThreshold = 250;\n","import {\n  Component,\n  Element,\n  Event,\n  EventEmitter,\n  h,\n  Host,\n  Listen,\n  Method,\n  Prop,\n  State,\n  VNode,\n  Watch,\n} from \"@stencil/core\";\nimport { guid } from \"../../utils/guid\";\nimport { intersects, isPrimaryPointerButton } from \"../../utils/dom\";\nimport {\n  afterConnectDefaultValueSet,\n  connectForm,\n  disconnectForm,\n  FormComponent,\n  HiddenFormInputSlot,\n} from \"../../utils/form\";\nimport {\n  connectInteractive,\n  disconnectInteractive,\n  InteractiveComponent,\n  InteractiveContainer,\n  updateHostInteraction,\n} from \"../../utils/interactive\";\nimport { isActivationKey } from \"../../utils/key\";\nimport { connectLabel, disconnectLabel, getLabelText, LabelableComponent } from \"../../utils/label\";\nimport {\n  componentFocusable,\n  LoadableComponent,\n  setComponentLoaded,\n  setUpLoadableComponent,\n} from \"../../utils/loadable\";\nimport {\n  connectLocalized,\n  disconnectLocalized,\n  LocalizedComponent,\n  NumberingSystem,\n  numberStringFormatter,\n} from \"../../utils/locale\";\nimport { clamp, decimalPlaces } from \"../../utils/math\";\nimport { ColorStop, DataSeries } from \"../graph/interfaces\";\nimport { Scale } from \"../interfaces\";\nimport { BigDecimal } from \"../../utils/number\";\nimport { CSS, maxTickElementThreshold } from \"./resources\";\nimport { ActiveSliderProperty, SetValueProperty, SideOffset, ThumbType } from \"./interfaces\";\n\nfunction isRange(value: number | number[]): value is number[] {\n  return Array.isArray(value);\n}\n\n@Component({\n  tag: \"calcite-slider\",\n  styleUrl: \"slider.scss\",\n  shadow: {\n    delegatesFocus: true,\n  },\n})\nexport class Slider\n  implements\n    LabelableComponent,\n    FormComponent,\n    InteractiveComponent,\n    LocalizedComponent,\n    LoadableComponent\n{\n  //--------------------------------------------------------------------------\n  //\n  //  Properties\n  //\n  //--------------------------------------------------------------------------\n\n  /** When `true`, interaction is prevented and the component is displayed with lower opacity. */\n  @Prop({ reflect: true }) disabled = false;\n\n  /**\n   * Used to configure where the fill is placed along the slider track in relation to the value handle.\n   *\n   * Range mode will always display the fill between the min and max handles.\n   */\n  @Prop({ reflect: true }) fillPlacement: \"start\" | \"none\" | \"end\" = \"start\";\n\n  /**\n   * The `id` of the form that will be associated with the component.\n   *\n   * When not set, the component will be associated with its ancestor form element, if any.\n   */\n  @Prop({ reflect: true }) form: string;\n\n  /**\n   * When `true`, number values are displayed with a group separator corresponding to the language and country format.\n   */\n  @Prop({ reflect: true }) groupSeparator = false;\n\n  /** When `true`, indicates a histogram is present. */\n  @Prop({ reflect: true, mutable: true }) hasHistogram = false;\n\n  /**\n   * A list of the histogram's x,y coordinates within the component's `min` and `max`. Displays above the component's track.\n   *\n   * @see [DataSeries](https://github.com/Esri/calcite-design-system/blob/dev/src/components/graph/interfaces.ts#L5)\n   */\n  @Prop() histogram: DataSeries;\n\n  @Watch(\"histogram\")\n  histogramWatcher(newHistogram: DataSeries): void {\n    this.hasHistogram = !!newHistogram;\n  }\n\n  /**\n   * A set of single color stops for a histogram, sorted by offset ascending.\n   */\n  @Prop() histogramStops: ColorStop[];\n\n  /** When `true`, displays label handles with their numeric value. */\n  @Prop({ reflect: true }) labelHandles = false;\n\n  /**\n   * When specified, allows users to customize handle labels.\n   */\n  @Prop() labelFormatter: (\n    value: number,\n    type: \"value\" | \"min\" | \"max\" | \"tick\",\n    defaultFormatter: (value: number) => string,\n  ) => string | undefined;\n\n  /** When `true` and `ticks` is specified, displays label tick marks with their numeric value. */\n  @Prop({ reflect: true }) labelTicks = false;\n\n  /** The component's maximum selectable value. */\n  @Prop({ reflect: true }) max = 100;\n\n  /** For multiple selections, the accessible name for the second handle, such as `\"Temperature, upper bound\"`. */\n  @Prop() maxLabel: string;\n\n  /** For multiple selections, the component's upper value. */\n  @Prop({ mutable: true }) maxValue: number;\n\n  /** The component's minimum selectable value. */\n  @Prop({ reflect: true }) min = 0;\n\n  /** Accessible name for first (or only) handle, such as `\"Temperature, lower bound\"`. */\n  @Prop() minLabel: string;\n\n  /** For multiple selections, the component's lower value. */\n  @Prop({ mutable: true }) minValue: number;\n\n  /**\n   * When `true`, the slider will display values from high to low.\n   *\n   * Note that this value will be ignored if the slider has an associated histogram.\n   */\n  @Prop({ reflect: true }) mirrored = false;\n\n  /**\n   * Specifies the name of the component.\n   *\n   * Required to pass the component's `value` on form submission.\n   */\n  @Prop({ reflect: true }) name: string;\n\n  /**\n   * Specifies the Unicode numeral system used by the component for localization.\n   */\n  @Prop() numberingSystem: NumberingSystem;\n\n  /** Specifies the interval to move with the page up, or page down keys. */\n  @Prop({ reflect: true }) pageStep: number;\n\n  /** When `true`, sets a finer point for handles. */\n  @Prop({ reflect: true }) precise = false;\n\n  /**\n   * When `true`, the component must have a value in order for the form to submit.\n   */\n  @Prop({ reflect: true }) required = false;\n\n  /** When `true`, enables snap selection in coordination with `step` via a mouse. */\n  @Prop({ reflect: true }) snap = false;\n\n  /** Specifies the interval to move with the up, or down keys. */\n  @Prop({ reflect: true }) step = 1;\n\n  /** Displays tick marks on the number line at a specified interval. */\n  @Prop({ reflect: true }) ticks: number;\n\n  @Watch(\"ticks\")\n  ticksWatcher(): void {\n    this.tickValues = this.generateTickValues();\n  }\n\n  /** The component's value. */\n  @Prop({ reflect: true, mutable: true }) value: null | number | number[] = 0;\n\n  @Watch(\"value\")\n  valueHandler(): void {\n    this.setMinMaxFromValue();\n  }\n\n  @Watch(\"minValue\")\n  @Watch(\"maxValue\")\n  minMaxValueHandler(): void {\n    this.setValueFromMinMax();\n  }\n\n  /**\n   *  Specifies the size of the component.\n   */\n  @Prop({ reflect: true }) scale: Scale = \"m\";\n\n  //--------------------------------------------------------------------------\n  //\n  //  Lifecycle\n  //\n  //--------------------------------------------------------------------------\n\n  connectedCallback(): void {\n    connectInteractive(this);\n    connectLocalized(this);\n    this.setMinMaxFromValue();\n    this.setValueFromMinMax();\n    connectLabel(this);\n    connectForm(this);\n  }\n\n  disconnectedCallback(): void {\n    disconnectInteractive(this);\n    disconnectLabel(this);\n    disconnectForm(this);\n    disconnectLocalized(this);\n    this.removeDragListeners();\n  }\n\n  componentWillLoad(): void {\n    setUpLoadableComponent(this);\n    if (!isRange(this.value)) {\n      this.value = this.snap ? this.getClosestStep(this.value) : this.clamp(this.value);\n    }\n    this.ticksWatcher();\n    this.histogramWatcher(this.histogram);\n    afterConnectDefaultValueSet(this, this.value);\n  }\n\n  componentDidLoad(): void {\n    setComponentLoaded(this);\n  }\n\n  componentDidRender(): void {\n    if (this.labelHandles) {\n      this.adjustHostObscuredHandleLabel(\"value\");\n      if (isRange(this.value)) {\n        this.adjustHostObscuredHandleLabel(\"minValue\");\n        if (!(this.precise && !this.hasHistogram)) {\n          this.hyphenateCollidingRangeHandleLabels();\n        }\n      }\n    }\n    this.hideObscuredBoundingTickLabels();\n    updateHostInteraction(this);\n  }\n\n  render(): VNode {\n    const id = this.el.id || this.guid;\n    const value = isRange(this.value) ? this.maxValue : this.value;\n    const min = this.minValue || this.min;\n    const useMinValue = this.shouldUseMinValue();\n    const minInterval = this.getUnitInterval(useMinValue ? this.minValue : min) * 100;\n    const maxInterval = this.getUnitInterval(value) * 100;\n    const mirror = this.shouldMirror();\n    const valueIsRange = isRange(this.value);\n\n    const thumbTypes = this.buildThumbType(\"max\");\n    const thumb = this.renderThumb({\n      type: thumbTypes,\n      thumbPlacement: thumbTypes.includes(\"histogram\") ? \"below\" : \"above\",\n      maxInterval,\n      minInterval,\n      mirror,\n    });\n\n    const minThumbTypes = this.buildThumbType(\"min\");\n    const minThumb =\n      valueIsRange &&\n      this.renderThumb({\n        type: minThumbTypes,\n        thumbPlacement:\n          minThumbTypes.includes(\"histogram\") || minThumbTypes.includes(\"precise\")\n            ? \"below\"\n            : \"above\",\n        maxInterval,\n        minInterval,\n        mirror,\n      });\n\n    const fillPlacement = valueIsRange ? \"start\" : this.fillPlacement;\n    const trackRangePlacementStyles =\n      fillPlacement === \"none\"\n        ? {\n            left: `unset`,\n            right: `unset`,\n          }\n        : fillPlacement === \"end\"\n          ? {\n              left: `${mirror ? minInterval : maxInterval}%`,\n              right: `${mirror ? maxInterval : minInterval}%`,\n            }\n          : /* default */\n            {\n              left: `${mirror ? 100 - maxInterval : minInterval}%`,\n              right: `${mirror ? minInterval : 100 - maxInterval}%`,\n            };\n\n    return (\n      <Host id={id} onKeyDown={this.handleKeyDown} onTouchStart={this.handleTouchStart}>\n        <InteractiveContainer disabled={this.disabled}>\n          <div\n            aria-label={getLabelText(this)}\n            class={{\n              [CSS.container]: true,\n              [CSS.containerRange]: valueIsRange,\n              [`scale--${this.scale}`]: true,\n            }}\n          >\n            {this.renderGraph()}\n            <div class={CSS.track} ref={this.storeTrackRef}>\n              <div\n                class={CSS.trackRange}\n                onPointerDown={this.onTrackPointerDown}\n                style={trackRangePlacementStyles}\n              />\n              <div class={CSS.ticks}>\n                {this.tickValues.map((tick) => {\n                  const tickOffset = `${this.getUnitInterval(tick) * 100}%`;\n\n                  let activeTicks: boolean = false;\n\n                  if (fillPlacement === \"start\" || fillPlacement === \"end\") {\n                    if (useMinValue) {\n                      activeTicks = tick >= this.minValue && tick <= this.maxValue;\n                    } else {\n                      const rangeStart = fillPlacement === \"start\" ? min : value;\n                      const rangeEnd = fillPlacement === \"start\" ? value : this.max;\n                      activeTicks = tick >= rangeStart && tick <= rangeEnd;\n                    }\n                  }\n\n                  return (\n                    <span\n                      class={{\n                        [CSS.tick]: true,\n                        [CSS.tickActive]: activeTicks,\n                      }}\n                      style={{\n                        left: mirror ? \"\" : tickOffset,\n                        right: mirror ? tickOffset : \"\",\n                      }}\n                    >\n                      {this.renderTickLabel(tick)}\n                    </span>\n                  );\n                })}\n              </div>\n            </div>\n            <div class={CSS.thumbContainer}>\n              {minThumb}\n              {thumb}\n              <HiddenFormInputSlot component={this} />\n            </div>\n          </div>\n        </InteractiveContainer>\n      </Host>\n    );\n  }\n\n  private renderThumb({\n    type,\n    mirror,\n    thumbPlacement,\n    minInterval,\n    maxInterval,\n  }: {\n    maxInterval: number;\n    minInterval: number;\n    mirror: boolean;\n    thumbPlacement: \"above\" | \"below\";\n    type: string;\n  }) {\n    const isLabeled = type.includes(\"labeled\");\n    const isPrecise = type.includes(\"precise\");\n    const isMinThumb = type.includes(\"min\");\n\n    const valueIsRange = isRange(this.value);\n    const value = isMinThumb\n      ? this.minValue\n      : valueIsRange\n        ? this.maxValue\n        : (this.value as number);\n    const valueProp = isMinThumb ? \"minValue\" : valueIsRange ? \"maxValue\" : \"value\";\n    const ariaLabel = isMinThumb ? this.minLabel : valueIsRange ? this.maxLabel : this.minLabel;\n    const ariaValuenow = isMinThumb ? this.minValue : value;\n    const displayedValue =\n      valueProp === \"minValue\"\n        ? this.internalLabelFormatter(this.minValue, \"min\")\n        : valueProp === \"maxValue\"\n          ? this.internalLabelFormatter(this.maxValue, \"max\")\n          : this.internalLabelFormatter(value, \"value\");\n    const thumbStyle: SideOffset = isMinThumb\n      ? { left: `${mirror ? 100 - minInterval : minInterval}%` }\n      : { right: `${mirror ? maxInterval : 100 - maxInterval}%` };\n    const thumbLabelClasses = `${CSS.handleLabel} ${\n      isMinThumb ? CSS.handleLabelMinValue : CSS.handleLabelValue\n    }`;\n\n    const labels = isLabeled\n      ? [\n          <span aria-hidden=\"true\" class={thumbLabelClasses}>\n            {displayedValue}\n          </span>,\n          <span aria-hidden=\"true\" class={`${thumbLabelClasses} ${CSS.static}`}>\n            {displayedValue}\n          </span>,\n          <span aria-hidden=\"true\" class={`${thumbLabelClasses} ${CSS.transformed}`}>\n            {displayedValue}\n          </span>,\n        ]\n      : [];\n\n    const thumbContent: VNode[] = [\n      ...labels,\n      <div class={CSS.handle} />,\n      isPrecise && <div class={CSS.handleExtension} />,\n    ];\n\n    if (thumbPlacement === \"below\") {\n      thumbContent.reverse();\n    }\n\n    return (\n      <div\n        aria-disabled={this.disabled}\n        aria-label={ariaLabel}\n        aria-orientation=\"horizontal\"\n        aria-valuemax={this.max}\n        aria-valuemin={this.min}\n        aria-valuenow={ariaValuenow}\n        class={{\n          [CSS.thumb]: true,\n          [CSS.thumbValue]: !isMinThumb,\n          [CSS.thumbActive]: this.lastDragProp !== \"minMaxValue\" && this.dragProp === valueProp,\n          [CSS.thumbPrecise]: isPrecise,\n          [CSS.thumbMinValue]: isMinThumb,\n        }}\n        data-value-prop={valueProp}\n        key={type}\n        onBlur={this.onThumbBlur}\n        onFocus={this.onThumbFocus}\n        onPointerDown={this.onThumbPointerDown}\n        ref={this.storeThumbRef}\n        role=\"slider\"\n        style={thumbStyle}\n        tabIndex={0}\n      >\n        {thumbContent}\n      </div>\n    );\n  }\n\n  private renderGraph(): VNode {\n    return this.histogram ? (\n      <calcite-graph\n        class={CSS.graph}\n        colorStops={this.histogramStops}\n        data={this.histogram}\n        highlightMax={isRange(this.value) ? this.maxValue : this.value}\n        highlightMin={isRange(this.value) ? this.minValue : this.min}\n        max={this.max}\n        min={this.min}\n      />\n    ) : null;\n  }\n\n  private renderTickLabel(tick: number): VNode {\n    const { hasHistogram, labelHandles, labelTicks, max, min, precise, value } = this;\n    const valueIsRange = isRange(value);\n    const isMinTickLabel = tick === min;\n    const isMaxTickLabel = tick === max;\n    const isAtEdge = isMinTickLabel || isMaxTickLabel;\n\n    const shouldDisplayLabel =\n      labelTicks &&\n      ((!hasHistogram && (isAtEdge || !precise || !valueIsRange)) ||\n        (hasHistogram && (isAtEdge || (!precise && !labelHandles))));\n\n    return shouldDisplayLabel ? (\n      <span\n        class={{\n          [CSS.tickLabel]: true,\n          [CSS.tickMin]: isMinTickLabel,\n          [CSS.tickMax]: isMaxTickLabel,\n        }}\n      >\n        {this.internalLabelFormatter(tick, \"tick\")}\n      </span>\n    ) : null;\n  }\n  //--------------------------------------------------------------------------\n  //\n  //  Event Listeners\n  //\n  //--------------------------------------------------------------------------\n\n  private handleKeyDown = (event: KeyboardEvent): void => {\n    const mirror = this.shouldMirror();\n    const { activeProp, max, min, pageStep, step } = this;\n    const value = this[activeProp];\n    const { key } = event;\n\n    if (isActivationKey(key)) {\n      event.preventDefault();\n      return;\n    }\n\n    let adjustment: number;\n\n    if (key === \"ArrowUp\" || key === \"ArrowRight\") {\n      const directionFactor = mirror && key === \"ArrowRight\" ? -1 : 1;\n      adjustment = value + step * directionFactor;\n    } else if (key === \"ArrowDown\" || key === \"ArrowLeft\") {\n      const directionFactor = mirror && key === \"ArrowLeft\" ? -1 : 1;\n      adjustment = value - step * directionFactor;\n    } else if (key === \"PageUp\") {\n      if (pageStep) {\n        adjustment = value + pageStep;\n      }\n    } else if (key === \"PageDown\") {\n      if (pageStep) {\n        adjustment = value - pageStep;\n      }\n    } else if (key === \"Home\") {\n      adjustment = min;\n    } else if (key === \"End\") {\n      adjustment = max;\n    }\n\n    if (isNaN(adjustment)) {\n      return;\n    }\n\n    event.preventDefault();\n    const fixedDecimalAdjustment = Number(adjustment.toFixed(decimalPlaces(step)));\n    this.setValue({\n      [activeProp as SetValueProperty]: this.clamp(fixedDecimalAdjustment, activeProp),\n    });\n  };\n\n  @Listen(\"pointerdown\")\n  pointerDownHandler(event: PointerEvent): void {\n    if (this.disabled || !isPrimaryPointerButton(event)) {\n      return;\n    }\n\n    const x = event.clientX || event.pageX;\n    const position = this.translate(x);\n    let prop: ActiveSliderProperty = \"value\";\n    if (isRange(this.value)) {\n      const inRange = position >= this.minValue && position <= this.maxValue;\n      if (inRange && this.lastDragProp === \"minMaxValue\") {\n        prop = \"minMaxValue\";\n      } else {\n        const closerToMax = Math.abs(this.maxValue - position) < Math.abs(this.minValue - position);\n        prop = closerToMax || position >= this.maxValue ? \"maxValue\" : \"minValue\";\n      }\n    }\n    this.lastDragPropValue = this[prop];\n    this.dragStart(prop);\n    const isThumbActive = this.el.shadowRoot.querySelector(`.${CSS.thumb}:active`);\n    if (!isThumbActive) {\n      this.setValue({ [prop as SetValueProperty]: this.clamp(position, prop) });\n    }\n    this.focusActiveHandle(x);\n  }\n\n  handleTouchStart(event: TouchEvent): void {\n    // needed to prevent extra click at the end of a handle drag\n    event.preventDefault();\n  }\n\n  //--------------------------------------------------------------------------\n  //\n  //  Events\n  //\n  //--------------------------------------------------------------------------\n  /**\n   * Fires on all updates to the component.\n   *\n   * Note: Fires frequently during drag. To perform\n   * expensive operations consider using a debounce or throttle to avoid\n   * locking up the main thread.\n   */\n  @Event({ cancelable: false }) calciteSliderInput: EventEmitter<void>;\n\n  /**\n   * Fires when the thumb is released on the component.\n   *\n   * Note: To constantly listen to the drag event,\n   * use `calciteSliderInput` instead.\n   */\n  @Event({ cancelable: false }) calciteSliderChange: EventEmitter<void>;\n\n  //--------------------------------------------------------------------------\n  //\n  //  Public Methods\n  //\n  //--------------------------------------------------------------------------\n\n  /** Sets focus on the component. */\n  @Method()\n  async setFocus(): Promise<void> {\n    await componentFocusable(this);\n\n    const handle = this.minHandle ? this.minHandle : this.maxHandle;\n    handle?.focus();\n  }\n\n  //--------------------------------------------------------------------------\n  //\n  //  Private State/Props\n  //\n  //--------------------------------------------------------------------------\n\n  @Element() el: HTMLCalciteSliderElement;\n\n  labelEl: HTMLCalciteLabelElement;\n\n  formEl: HTMLFormElement;\n\n  defaultValue: Slider[\"value\"];\n\n  private activeProp: ActiveSliderProperty = \"value\";\n\n  private guid = `calcite-slider-${guid()}`;\n\n  private dragProp: ActiveSliderProperty;\n\n  private lastDragProp: ActiveSliderProperty;\n\n  private lastDragPropValue: number;\n\n  private minHandle: HTMLDivElement;\n\n  private maxHandle: HTMLDivElement;\n\n  private trackEl: HTMLDivElement;\n\n  @State() effectiveLocale = \"\";\n\n  @State() private minMaxValueRange: number = null;\n\n  @State() private minValueDragRange: number = null;\n\n  @State() private maxValueDragRange: number = null;\n\n  @State() private tickValues: number[] = [];\n\n  //--------------------------------------------------------------------------\n  //\n  //  Private Methods\n  //\n  //--------------------------------------------------------------------------\n\n  private buildThumbType(type: \"min\" | \"max\"): ThumbType {\n    const thumbTypeParts: string[] = [type];\n\n    if (this.labelHandles) {\n      thumbTypeParts.push(\"labeled\");\n    }\n\n    if (this.precise) {\n      thumbTypeParts.push(\"precise\");\n    }\n\n    if (this.hasHistogram) {\n      thumbTypeParts.push(\"histogram\");\n    }\n\n    return thumbTypeParts.join(\"-\") as ThumbType;\n  }\n\n  setValueFromMinMax(): void {\n    const { minValue, maxValue } = this;\n\n    if (typeof minValue === \"number\" && typeof maxValue === \"number\") {\n      this.value = [minValue, maxValue];\n    }\n  }\n\n  setMinMaxFromValue(): void {\n    const { value } = this;\n\n    if (isRange(value)) {\n      this.minValue = value[0];\n      this.maxValue = value[1];\n    }\n  }\n\n  onLabelClick(): void {\n    this.setFocus();\n  }\n\n  private shouldMirror(): boolean {\n    return this.mirrored && !this.hasHistogram;\n  }\n\n  private shouldUseMinValue(): boolean {\n    if (!isRange(this.value)) {\n      return false;\n    }\n    return (\n      (this.hasHistogram && this.maxValue === 0) || (!this.hasHistogram && this.minValue === 0)\n    );\n  }\n\n  private getTickDensity(): number {\n    const density = (this.max - this.min) / this.ticks / maxTickElementThreshold;\n\n    return density < 1 ? 1 : density;\n  }\n\n  private generateTickValues(): number[] {\n    const tickInterval = this.ticks ?? 0;\n\n    if (tickInterval <= 0) {\n      return [];\n    }\n\n    const ticks: number[] = [this.min];\n    const density = this.getTickDensity();\n    const tickOffset = tickInterval * density;\n    let current = this.min;\n\n    while (current < this.max) {\n      current += tickOffset;\n      ticks.push(Math.min(current, this.max));\n    }\n\n    if (!ticks.includes(this.max)) {\n      ticks.push(this.max);\n    }\n\n    return ticks;\n  }\n\n  private onThumbBlur = () => {\n    this.activeProp = null;\n  };\n\n  private onThumbFocus = (event: FocusEvent) => {\n    const thumb = event.currentTarget as HTMLElement;\n    this.activeProp = thumb.getAttribute(\"data-value-prop\") as ActiveSliderProperty;\n  };\n\n  private onThumbPointerDown = (event: PointerEvent) => {\n    const thumb = event.currentTarget as HTMLElement;\n    this.pointerDownDragStart(event, thumb.getAttribute(\"data-value-prop\") as ActiveSliderProperty);\n  };\n\n  private onTrackPointerDown = (event: PointerEvent) => {\n    this.pointerDownDragStart(event, \"minMaxValue\");\n  };\n\n  private pointerDownDragStart(event: PointerEvent, prop: ActiveSliderProperty): void {\n    if (!isPrimaryPointerButton(event)) {\n      return;\n    }\n\n    this.dragStart(prop);\n  }\n\n  private dragStart(prop: ActiveSliderProperty): void {\n    this.dragProp = prop;\n    this.lastDragProp = this.dragProp;\n    this.activeProp = prop;\n    window.addEventListener(\"pointermove\", this.dragUpdate);\n    window.addEventListener(\"pointerup\", this.pointerUpDragEnd);\n    window.addEventListener(\"pointercancel\", this.dragEnd);\n  }\n\n  private focusActiveHandle(valueX: number): void {\n    if (this.dragProp === \"minValue\") {\n      this.minHandle.focus();\n    } else if (this.dragProp === \"maxValue\" || this.dragProp === \"value\") {\n      this.maxHandle.focus();\n    } else if (this.dragProp === \"minMaxValue\") {\n      this.getClosestHandle(valueX).focus();\n    }\n  }\n\n  private dragUpdate = (event: PointerEvent): void => {\n    if (this.disabled) {\n      return;\n    }\n\n    event.preventDefault();\n    if (this.dragProp) {\n      const value = this.translate(event.clientX || event.pageX);\n      if (isRange(this.value) && this.dragProp === \"minMaxValue\") {\n        if (this.minValueDragRange && this.maxValueDragRange && this.minMaxValueRange) {\n          const newMinValue = value - this.minValueDragRange;\n          const newMaxValue = value + this.maxValueDragRange;\n          if (\n            newMaxValue <= this.max &&\n            newMinValue >= this.min &&\n            newMaxValue - newMinValue === this.minMaxValueRange\n          ) {\n            this.setValue({\n              minValue: this.clamp(newMinValue, \"minValue\"),\n              maxValue: this.clamp(newMaxValue, \"maxValue\"),\n            });\n          }\n        } else {\n          this.minValueDragRange = value - this.minValue;\n          this.maxValueDragRange = this.maxValue - value;\n          this.minMaxValueRange = this.maxValue - this.minValue;\n        }\n      } else {\n        this.setValue({ [this.dragProp as SetValueProperty]: this.clamp(value, this.dragProp) });\n      }\n    }\n  };\n\n  private emitInput(): void {\n    this.calciteSliderInput.emit();\n  }\n\n  private emitChange(): void {\n    this.calciteSliderChange.emit();\n  }\n\n  private pointerUpDragEnd = (event: PointerEvent): void => {\n    if (this.disabled || !isPrimaryPointerButton(event)) {\n      return;\n    }\n\n    this.dragEnd(event);\n  };\n\n  private dragEnd = (event: PointerEvent): void => {\n    if (this.disabled) {\n      return;\n    }\n\n    this.removeDragListeners();\n    this.focusActiveHandle(event.clientX);\n    if (this.lastDragPropValue != this[this.dragProp]) {\n      this.emitChange();\n    }\n    this.dragProp = null;\n    this.lastDragPropValue = null;\n    this.minValueDragRange = null;\n    this.maxValueDragRange = null;\n    this.minMaxValueRange = null;\n  };\n\n  private removeDragListeners() {\n    window.removeEventListener(\"pointermove\", this.dragUpdate);\n    window.removeEventListener(\"pointerup\", this.pointerUpDragEnd);\n    window.removeEventListener(\"pointercancel\", this.dragEnd);\n  }\n\n  /**\n   * Set prop value(s) if changed at the component level\n   *\n   * @param {object} values - a set of key/value pairs delineating what properties in the component to update\n   */\n  private setValue(\n    values: Partial<{\n      [Property in keyof Pick<Slider, \"maxValue\" | \"minValue\" | \"value\">]: number;\n    }>,\n  ): void {\n    let valueChanged: boolean;\n\n    Object.keys(values).forEach((propName) => {\n      const newValue = values[propName];\n\n      if (!valueChanged) {\n        const oldValue = this[propName];\n        valueChanged = oldValue !== newValue;\n      }\n\n      this[propName] = newValue;\n    });\n\n    if (!valueChanged) {\n      return;\n    }\n\n    const dragging = this.dragProp;\n    if (!dragging) {\n      this.emitChange();\n    }\n    this.emitInput();\n  }\n\n  private storeTrackRef = (node: HTMLDivElement): void => {\n    this.trackEl = node;\n  };\n\n  private storeThumbRef = (el: HTMLDivElement): void => {\n    if (!el) {\n      return;\n    }\n\n    const valueProp = el.getAttribute(\"data-value-prop\") as ActiveSliderProperty;\n    valueProp === \"minValue\" ? (this.minHandle = el) : (this.maxHandle = el);\n  };\n\n  /**\n   * If number is outside range, constrain to min or max\n   *\n   * @param value\n   * @param prop\n   * @internal\n   */\n  private clamp(value: number, prop?: ActiveSliderProperty): number {\n    value = clamp(value, this.min, this.max);\n\n    // ensure that maxValue and minValue don't swap positions\n    if (prop === \"maxValue\") {\n      value = Math.max(value, this.minValue);\n    }\n    if (prop === \"minValue\") {\n      value = Math.min(value, this.maxValue);\n    }\n\n    return value;\n  }\n\n  /**\n   * Translate a pixel position to value along the range\n   *\n   * @param x\n   * @internal\n   */\n  private translate(x: number): number {\n    const range = this.max - this.min;\n    const { left, width } = this.trackEl.getBoundingClientRect();\n    const percent = (x - left) / width;\n    const mirror = this.shouldMirror();\n    const clampedValue = this.clamp(this.min + range * (mirror ? 1 - percent : percent));\n    const value = Number(clampedValue.toFixed(decimalPlaces(this.step)));\n\n    return !(this.snap && this.step) ? value : this.getClosestStep(value);\n  }\n\n  /**\n   * Get closest allowed value along stepped values\n   *\n   * @param value\n   * @internal\n   */\n  private getClosestStep(value: number): number {\n    const { max, min, step } = this;\n\n    // prevents floating point precision issues\n    const bigDecimalString = new BigDecimal(`${Math.floor((value - min) / step)}`)\n      .multiply(`${step}`)\n      .add(`${min}`)\n      .toString();\n\n    let snappedValue = this.clamp(Number(bigDecimalString));\n\n    if (snappedValue > max) {\n      snappedValue -= step;\n    }\n\n    return snappedValue;\n  }\n\n  private getClosestHandle(valueX: number): HTMLDivElement {\n    return this.getDistanceX(this.maxHandle, valueX) > this.getDistanceX(this.minHandle, valueX)\n      ? this.minHandle\n      : this.maxHandle;\n  }\n\n  private getDistanceX(el: HTMLDivElement, valueX: number): number {\n    return Math.abs(el.getBoundingClientRect().left - valueX);\n  }\n\n  private getFontSizeForElement(element: HTMLElement): number {\n    return Number(window.getComputedStyle(element).getPropertyValue(\"font-size\").match(/\\d+/)[0]);\n  }\n\n  /**\n   * Get position of value along range as fractional value\n   *\n   * @param num\n   * @return {number} number in the unit interval [0,1]\n   * @internal\n   */\n  private getUnitInterval(num: number): number {\n    num = this.clamp(num);\n    const range = this.max - this.min;\n    return (num - this.min) / range;\n  }\n\n  private adjustHostObscuredHandleLabel(name: \"value\" | \"minValue\"): void {\n    const label: HTMLSpanElement = this.el.shadowRoot.querySelector(`.handle__label--${name}`);\n    const labelStatic: HTMLSpanElement = this.el.shadowRoot.querySelector(\n      `.handle__label--${name}.static`,\n    );\n    const labelTransformed: HTMLSpanElement = this.el.shadowRoot.querySelector(\n      `.handle__label--${name}.transformed`,\n    );\n    const labelStaticBounds = labelStatic.getBoundingClientRect();\n    const labelStaticOffset = this.getHostOffset(labelStaticBounds.left, labelStaticBounds.right);\n    label.style.transform = `translateX(${labelStaticOffset}px)`;\n    labelTransformed.style.transform = `translateX(${labelStaticOffset}px)`;\n  }\n\n  private hyphenateCollidingRangeHandleLabels(): void {\n    const { shadowRoot } = this.el;\n\n    const mirror = this.shouldMirror();\n    const leftModifier = mirror ? \"value\" : \"minValue\";\n    const rightModifier = mirror ? \"minValue\" : \"value\";\n\n    const leftValueLabel: HTMLSpanElement = shadowRoot.querySelector(\n      `.handle__label--${leftModifier}`,\n    );\n    const leftValueLabelStatic: HTMLSpanElement = shadowRoot.querySelector(\n      `.handle__label--${leftModifier}.static`,\n    );\n    const leftValueLabelTransformed: HTMLSpanElement = shadowRoot.querySelector(\n      `.handle__label--${leftModifier}.transformed`,\n    );\n    const leftValueLabelStaticHostOffset = this.getHostOffset(\n      leftValueLabelStatic.getBoundingClientRect().left,\n      leftValueLabelStatic.getBoundingClientRect().right,\n    );\n\n    const rightValueLabel: HTMLSpanElement = shadowRoot.querySelector(\n      `.handle__label--${rightModifier}`,\n    );\n    const rightValueLabelStatic: HTMLSpanElement = shadowRoot.querySelector(\n      `.handle__label--${rightModifier}.static`,\n    );\n    const rightValueLabelTransformed: HTMLSpanElement = shadowRoot.querySelector(\n      `.handle__label--${rightModifier}.transformed`,\n    );\n    const rightValueLabelStaticHostOffset = this.getHostOffset(\n      rightValueLabelStatic.getBoundingClientRect().left,\n      rightValueLabelStatic.getBoundingClientRect().right,\n    );\n\n    const labelFontSize = this.getFontSizeForElement(leftValueLabel);\n    const labelTransformedOverlap = this.getRangeLabelOverlap(\n      leftValueLabelTransformed,\n      rightValueLabelTransformed,\n    );\n\n    const hyphenLabel = leftValueLabel;\n    const labelOffset = labelFontSize / 2;\n\n    if (labelTransformedOverlap > 0) {\n      hyphenLabel.classList.add(CSS.hyphen, CSS.hyphenWrap);\n      if (rightValueLabelStaticHostOffset === 0 && leftValueLabelStaticHostOffset === 0) {\n        // Neither handle overlaps the host boundary\n        let leftValueLabelTranslate = labelTransformedOverlap / 2 - labelOffset;\n        leftValueLabelTranslate =\n          Math.sign(leftValueLabelTranslate) === -1\n            ? Math.abs(leftValueLabelTranslate)\n            : -leftValueLabelTranslate;\n\n        const leftValueLabelTransformedHostOffset = this.getHostOffset(\n          leftValueLabelTransformed.getBoundingClientRect().left +\n            leftValueLabelTranslate -\n            labelOffset,\n          leftValueLabelTransformed.getBoundingClientRect().right +\n            leftValueLabelTranslate -\n            labelOffset,\n        );\n\n        let rightValueLabelTranslate = labelTransformedOverlap / 2;\n        const rightValueLabelTransformedHostOffset = this.getHostOffset(\n          rightValueLabelTransformed.getBoundingClientRect().left + rightValueLabelTranslate,\n          rightValueLabelTransformed.getBoundingClientRect().right + rightValueLabelTranslate,\n        );\n\n        if (leftValueLabelTransformedHostOffset !== 0) {\n          leftValueLabelTranslate += leftValueLabelTransformedHostOffset;\n          rightValueLabelTranslate += leftValueLabelTransformedHostOffset;\n        }\n\n        if (rightValueLabelTransformedHostOffset !== 0) {\n          leftValueLabelTranslate += rightValueLabelTransformedHostOffset;\n          rightValueLabelTranslate += rightValueLabelTransformedHostOffset;\n        }\n\n        leftValueLabel.style.transform = `translateX(${leftValueLabelTranslate}px)`;\n        leftValueLabelTransformed.style.transform = `translateX(${\n          leftValueLabelTranslate - labelOffset\n        }px)`;\n        rightValueLabel.style.transform = `translateX(${rightValueLabelTranslate}px)`;\n        rightValueLabelTransformed.style.transform = `translateX(${rightValueLabelTranslate}px)`;\n      } else if (leftValueLabelStaticHostOffset > 0 || rightValueLabelStaticHostOffset > 0) {\n        // labels overlap host boundary on the left side\n        leftValueLabel.style.transform = `translateX(${\n          leftValueLabelStaticHostOffset + labelOffset\n        }px)`;\n        rightValueLabel.style.transform = `translateX(${\n          labelTransformedOverlap + rightValueLabelStaticHostOffset\n        }px)`;\n        rightValueLabelTransformed.style.transform = `translateX(${\n          labelTransformedOverlap + rightValueLabelStaticHostOffset\n        }px)`;\n      } else if (leftValueLabelStaticHostOffset < 0 || rightValueLabelStaticHostOffset < 0) {\n        // labels overlap host boundary on the right side\n        let leftValueLabelTranslate =\n          Math.abs(leftValueLabelStaticHostOffset) + labelTransformedOverlap - labelOffset;\n        leftValueLabelTranslate =\n          Math.sign(leftValueLabelTranslate) === -1\n            ? Math.abs(leftValueLabelTranslate)\n            : -leftValueLabelTranslate;\n        leftValueLabel.style.transform = `translateX(${leftValueLabelTranslate}px)`;\n        leftValueLabelTransformed.style.transform = `translateX(${\n          leftValueLabelTranslate - labelOffset\n        }px)`;\n      }\n    } else {\n      hyphenLabel.classList.remove(CSS.hyphen, CSS.hyphenWrap);\n      leftValueLabel.style.transform = `translateX(${leftValueLabelStaticHostOffset}px)`;\n      leftValueLabelTransformed.style.transform = `translateX(${leftValueLabelStaticHostOffset}px)`;\n      rightValueLabel.style.transform = `translateX(${rightValueLabelStaticHostOffset}px)`;\n      rightValueLabelTransformed.style.transform = `translateX(${rightValueLabelStaticHostOffset}px)`;\n    }\n  }\n\n  /**\n   * Hides bounding tick labels that are obscured by either handle.\n   */\n  private hideObscuredBoundingTickLabels(): void {\n    const valueIsRange = isRange(this.value);\n    if (!this.hasHistogram && !valueIsRange && !this.labelHandles && !this.precise) {\n      return;\n    }\n    if (!this.hasHistogram && !valueIsRange && this.labelHandles && !this.precise) {\n      return;\n    }\n    if (!this.hasHistogram && !valueIsRange && !this.labelHandles && this.precise) {\n      return;\n    }\n    if (!this.hasHistogram && !valueIsRange && this.labelHandles && this.precise) {\n      return;\n    }\n    if (!this.hasHistogram && valueIsRange && !this.precise) {\n      return;\n    }\n    if (this.hasHistogram && !this.precise && !this.labelHandles) {\n      return;\n    }\n\n    const minHandle: HTMLDivElement | null = this.el.shadowRoot.querySelector(\n      `.${CSS.thumbMinValue}`,\n    );\n    const maxHandle: HTMLDivElement | null = this.el.shadowRoot.querySelector(`.${CSS.thumbValue}`);\n\n    const minTickLabel: HTMLSpanElement | null = this.el.shadowRoot.querySelector(\n      `.${CSS.tickMin}`,\n    );\n    const maxTickLabel: HTMLSpanElement | null = this.el.shadowRoot.querySelector(\n      `.${CSS.tickMax}`,\n    );\n\n    if (!minHandle && maxHandle && minTickLabel && maxTickLabel) {\n      minTickLabel.style.opacity = this.isMinTickLabelObscured(minTickLabel, maxHandle) ? \"0\" : \"1\";\n      maxTickLabel.style.opacity = this.isMaxTickLabelObscured(maxTickLabel, maxHandle) ? \"0\" : \"1\";\n    }\n\n    if (minHandle && maxHandle && minTickLabel && maxTickLabel) {\n      minTickLabel.style.opacity =\n        this.isMinTickLabelObscured(minTickLabel, minHandle) ||\n        this.isMinTickLabelObscured(minTickLabel, maxHandle)\n          ? \"0\"\n          : \"1\";\n      maxTickLabel.style.opacity =\n        this.isMaxTickLabelObscured(maxTickLabel, minHandle) ||\n        (this.isMaxTickLabelObscured(maxTickLabel, maxHandle) && this.hasHistogram)\n          ? \"0\"\n          : \"1\";\n    }\n  }\n\n  /**\n   * Returns an integer representing the number of pixels to offset on the left or right side based on desired position behavior.\n   *\n   * @param leftBounds\n   * @param rightBounds\n   * @internal\n   */\n  private getHostOffset(leftBounds: number, rightBounds: number): number {\n    const hostBounds = this.el.getBoundingClientRect();\n    const buffer = 7;\n\n    if (leftBounds + buffer < hostBounds.left) {\n      return hostBounds.left - leftBounds - buffer;\n    }\n\n    if (rightBounds - buffer > hostBounds.right) {\n      return -(rightBounds - hostBounds.right) + buffer;\n    }\n\n    return 0;\n  }\n\n  /**\n   * Returns an integer representing the number of pixels that the two given span elements are overlapping, taking into account\n   * a space in between the two spans equal to the font-size set on them to account for the space needed to render a hyphen.\n   *\n   * @param leftLabel\n   * @param rightLabel\n   */\n  private getRangeLabelOverlap(leftLabel: HTMLSpanElement, rightLabel: HTMLSpanElement): number {\n    const leftLabelBounds = leftLabel.getBoundingClientRect();\n    const rightLabelBounds = rightLabel.getBoundingClientRect();\n    const leftLabelFontSize = this.getFontSizeForElement(leftLabel);\n    const rangeLabelOverlap = leftLabelBounds.right + leftLabelFontSize - rightLabelBounds.left;\n\n    return Math.max(rangeLabelOverlap, 0);\n  }\n\n  /**\n   * Returns a boolean value representing if the minLabel span element is obscured (being overlapped) by the given handle div element.\n   *\n   * @param minLabel\n   * @param handle\n   */\n  private isMinTickLabelObscured(minLabel: HTMLSpanElement, handle: HTMLDivElement): boolean {\n    const minLabelBounds = minLabel.getBoundingClientRect();\n    const handleBounds = handle.getBoundingClientRect();\n    return intersects(minLabelBounds, handleBounds);\n  }\n\n  /**\n   * Returns a boolean value representing if the maxLabel span element is obscured (being overlapped) by the given handle div element.\n   *\n   * @param maxLabel\n   * @param handle\n   */\n  private isMaxTickLabelObscured(maxLabel: HTMLSpanElement, handle: HTMLDivElement): boolean {\n    const maxLabelBounds = maxLabel.getBoundingClientRect();\n    const handleBounds = handle.getBoundingClientRect();\n    return intersects(maxLabelBounds, handleBounds);\n  }\n\n  /**\n   * Returns a string representing the localized label value based if the groupSeparator prop is parsed.\n   *\n   * @param value\n   */\n  private formatValue = (value: number): string => {\n    numberStringFormatter.numberFormatOptions = {\n      locale: this.effectiveLocale,\n      numberingSystem: this.numberingSystem,\n      useGrouping: this.groupSeparator,\n    };\n\n    return numberStringFormatter.localize(value.toString());\n  };\n\n  private internalLabelFormatter(value: number, type: \"max\" | \"min\" | \"value\" | \"tick\"): string {\n    const customFormatter = this.labelFormatter;\n\n    if (!customFormatter) {\n      return this.formatValue(value);\n    }\n\n    const formattedValue = customFormatter(value, type, this.formatValue);\n\n    if (formattedValue == null) {\n      return this.formatValue(value);\n    }\n\n    return formattedValue;\n  }\n}\n",".scale--s {\n  --calcite-slider-handle-size: theme(\"spacing[2.5]\");\n  --calcite-slider-handle-extension-height: 0.4rem;\n  --calcite-slider-container-font-size: var(--calcite-font-size--3);\n  .handle__label,\n  .tick__label {\n    @apply leading-3;\n  }\n}\n\n.scale--m {\n  --calcite-slider-handle-size: theme(\"spacing[3.5]\");\n  --calcite-slider-handle-extension-height: 0.5rem;\n  --calcite-slider-container-font-size: var(--calcite-font-size--2);\n  .handle__label,\n  .tick__label {\n    @apply leading-4;\n  }\n}\n\n.scale--l {\n  --calcite-slider-handle-size: 1rem;\n  --calcite-slider-handle-extension-height: 0.65rem;\n  --calcite-slider-container-font-size: var(--calcite-font-size--1);\n  .handle__label,\n  .tick__label {\n    @apply leading-4;\n  }\n}\n\n.handle__label,\n.tick__label {\n  @apply text-color-2 font-medium;\n  font-size: var(--calcite-slider-container-font-size);\n}\n\n:host {\n  @apply block;\n}\n\n.container {\n  @apply relative block break-normal;\n  padding-inline: calc(var(--calcite-slider-handle-size) * 0.5);\n  padding-block: calc(var(--calcite-slider-handle-size) * 0.5);\n  margin-block: calc(var(--calcite-slider-handle-size) * 0.5);\n  margin-inline: 0;\n  --calcite-slider-full-handle-height: calc(\n    var(--calcite-slider-handle-size) + var(--calcite-slider-handle-extension-height)\n  );\n  touch-action: none;\n  // disable browser swipe navigation to prevent interference with the slide thumb following a touch gesture\n  user-select: none;\n}\n\n@include disabled() {\n  .track__range,\n  .tick--active {\n    background-color: var(--calcite-color-text-3);\n  }\n}\n\n.scale--s {\n  .thumb:not(.thumb--precise) {\n    --calcite-slider-thumb-y-offset: -0.375rem;\n  }\n}\n.scale--m {\n  .thumb:not(.thumb--precise) {\n    --calcite-slider-thumb-y-offset: -0.5rem;\n  }\n}\n.scale--l {\n  .thumb:not(.thumb--precise) {\n    --calcite-slider-thumb-y-offset: -0.55rem;\n  }\n}\n\n:host([precise]:not([has-histogram])) {\n  .container .thumb--value {\n    --calcite-slider-thumb-y-offset: calc(var(--calcite-slider-full-handle-height) * -1);\n  }\n}\n\n.thumb-container {\n  @apply relative max-w-full;\n}\n\n.thumb {\n  --calcite-slider-thumb-x-offset: calc(var(--calcite-slider-handle-size) * 0.5);\n  @apply font-inherit\n    absolute\n    m-0\n    flex\n    cursor-pointer\n    flex-col\n    items-center\n    border-none\n    bg-transparent\n    p-0\n    outline-none;\n  transform: translate(var(--calcite-slider-thumb-x-offset), var(--calcite-slider-thumb-y-offset));\n\n  .handle__label {\n    &.static,\n    &.transformed {\n      @apply absolute\n        top-0\n        bottom-0\n        opacity-0;\n    }\n    &.hyphen::after {\n      content: \"\\2014\";\n      display: inline-block;\n      inline-size: 1em;\n    }\n    &.hyphen--wrap {\n      display: flex;\n    }\n  }\n\n  .handle {\n    @apply focus-base\n      bg-foreground-1\n      box-border\n      rounded-full;\n    block-size: var(--calcite-slider-handle-size);\n    inline-size: var(--calcite-slider-handle-size);\n    box-shadow: 0 0 0 2px var(--calcite-color-text-3) inset;\n    transition:\n      border var(--calcite-internal-animation-timing-medium) ease,\n      background-color var(--calcite-internal-animation-timing-medium) ease,\n      box-shadow var(--calcite-animation-timing) ease;\n  }\n\n  .handle-extension {\n    @apply w-0.5;\n    block-size: var(--calcite-slider-handle-extension-height);\n    background-color: var(--calcite-color-text-3);\n  }\n\n  &:hover {\n    .handle {\n      box-shadow: 0 0 0 3px var(--calcite-color-brand) inset;\n    }\n    .handle-extension {\n      @apply bg-brand;\n    }\n  }\n\n  &:focus {\n    .handle {\n      @apply focus-outset;\n    }\n    .handle-extension {\n      @apply bg-brand;\n    }\n  }\n\n  &.thumb--minValue {\n    transform: translate(calc(var(--calcite-slider-thumb-x-offset) * -1), var(--calcite-slider-thumb-y-offset));\n  }\n\n  &.thumb--precise {\n    --calcite-slider-thumb-y-offset: -0.125rem;\n  }\n}\n\n:host([label-handles]) {\n  .thumb {\n    --calcite-slider-thumb-x-offset: 50%;\n  }\n  &:host(:not([has-histogram])) {\n    .scale--s {\n      .thumb:not(.thumb--precise) {\n        --calcite-slider-thumb-y-offset: -1.4375rem;\n      }\n    }\n    .scale--m {\n      .thumb:not(.thumb--precise) {\n        --calcite-slider-thumb-y-offset: -1.875rem;\n      }\n    }\n    .scale--l {\n      .thumb:not(.thumb--precise) {\n        --calcite-slider-thumb-y-offset: -2rem;\n      }\n    }\n  }\n}\n\n:host([has-histogram][label-handles]),\n:host([label-handles]:not([has-histogram])) .thumb--minValue.thumb--precise {\n  .handle__label {\n    margin-block-start: 0.5em;\n  }\n}\n:host(:not([has-histogram]):not([precise])),\n:host([label-handles]:not([has-histogram])) .thumb--value {\n  .handle__label {\n    margin-block-end: 0.5em;\n  }\n}\n\n:host([label-handles][precise]) {\n  &:host(:not([has-histogram])) .scale--s .thumb--value {\n    --calcite-slider-thumb-y-offset: -2.075rem;\n  }\n  &:host(:not([has-histogram])) .scale--m .thumb--value {\n    --calcite-slider-thumb-y-offset: -2.75rem;\n  }\n  &:host(:not([has-histogram])) .scale--l .thumb--value {\n    --calcite-slider-thumb-y-offset: -3.0625rem;\n  }\n}\n\n.thumb:focus,\n.thumb--active {\n  .handle {\n    @apply bg-brand;\n    box-shadow: 0 0 8px 0 rgb(0 0 0 / 16%); // shadow 1 press\n  }\n}\n\n.thumb:hover.thumb--precise::after,\n.thumb:focus.thumb--precise::after,\n.thumb--active.thumb--precise::after {\n  @apply bg-brand;\n}\n\n.track {\n  @apply relative h-0.5 rounded-none;\n  background-color: var(--calcite-color-border-2);\n  transition: all var(--calcite-internal-animation-timing-medium) ease-in;\n}\n\n.track__range {\n  @apply bg-brand\n  absolute\n  top-0\n  h-0.5;\n}\n.container--range {\n  .track__range {\n    &:hover {\n      cursor: ew-resize;\n    }\n    &::after {\n      @apply absolute w-full;\n      content: \"\";\n      inset-block-start: calc(calc(var(--calcite-slider-full-handle-height) * 0.5) * -1);\n      block-size: calc(var(--calcite-slider-handle-size) + var(--calcite-slider-handle-extension-height));\n    }\n  }\n}\n\n@media (forced-colors: active) {\n  .thumb {\n    outline-width: 0;\n    outline-offset: 0;\n  }\n  .handle {\n    @apply outline-none;\n  }\n  .thumb:focus .handle,\n  .thumb .handle-extension,\n  .thumb:hover .handle-extension,\n  .thumb:focus .handle-extension,\n  .thumb:active .handle-extension {\n    background-color: canvasText;\n  }\n  .track {\n    background-color: canvasText;\n  }\n  .track__range {\n    background-color: highlight;\n  }\n}\n\n.tick {\n  @apply absolute\n    h-1\n    w-0.5\n    border\n    border-solid;\n  background-color: var(--calcite-color-border-input);\n  border-color: var(--calcite-color-foreground-1);\n  inset-block-start: -2px;\n  pointer-events: none;\n  margin-inline-start: calc(-1 * theme(\"margin[0.5]\"));\n}\n\n.tick--active {\n  @apply bg-brand;\n}\n\n.tick__label {\n  @apply pointer-events-none\n    mt-3.5\n    flex\n    justify-center;\n}\n\n.tick__label--min {\n  transition: opacity var(--calcite-animation-timing);\n}\n\n.tick__label--max {\n  transition: opacity var(--calcite-internal-animation-timing-fast);\n}\n\n:host([has-histogram][label-handles]),\n:host([has-histogram][precise]) {\n  .tick__label--min,\n  .tick__label--max {\n    @apply text-color-3 font-normal;\n  }\n}\n\n.graph {\n  color: var(--calcite-color-foreground-3);\n  block-size: 48px;\n}\n\n// Ensure we have enough space on variants with text elements to prevent overlap\n:host([label-ticks][ticks]) {\n  .container {\n    // match tick__label top margin + font-size\n    padding-block-end: calc(theme(\"margin[3.5]\") + var(--calcite-slider-container-font-size));\n  }\n}\n:host([has-histogram]) {\n  &:host([precise][label-handles]) {\n    .container {\n      padding-block-end: calc(var(--calcite-slider-full-handle-height) + 1em);\n    }\n  }\n  &:host([label-handles]:not([precise])) {\n    .container {\n      padding-block-end: calc(calc(var(--calcite-slider-handle-size) * 0.5) + 1em);\n    }\n  }\n  &:host([precise]:not([label-handles])) {\n    .container {\n      padding-block-end: var(--calcite-slider-full-handle-height);\n    }\n  }\n}\n:host(:not([has-histogram])) {\n  &:host([precise]:not([label-handles])) {\n    .container {\n      padding-block-start: var(--calcite-slider-full-handle-height);\n    }\n    .container--range {\n      padding-block-end: var(--calcite-slider-full-handle-height);\n    }\n  }\n  &:host([label-handles]:not([precise])) {\n    .container {\n      padding-block-start: calc(var(--calcite-slider-full-handle-height) + 4px);\n    }\n  }\n  &:host([label-handles][precise]) {\n    .container {\n      padding-block-start: calc(\n        var(--calcite-slider-full-handle-height) + var(--calcite-slider-container-font-size) + 4px\n      );\n    }\n    .container--range {\n      padding-block-end: calc(\n        var(--calcite-slider-full-handle-height) + var(--calcite-slider-container-font-size) + 4px\n      );\n    }\n  }\n}\n\n@include hidden-form-input();\n@include base-component();\n","export const clamp = (value: number, min: number, max: number): number => Math.max(min, Math.min(value, max));\n\nconst decimalNumberRegex = new RegExp(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n\n/**\n * Returns the quantity of real decimal places for a number, which excludes trailing zeros.\n *\n * Adapted from {@link https://stackoverflow.com/questions/10454518/javascript-how-to-retrieve-the-number-of-decimals-of-a-string-number}.\n *\n * @param decimal - decimal value\n * @param value\n * @returns {number} the amount of decimal places in a number\n */\nexport const decimalPlaces = (value: number | string): number => {\n  const match = (\"\" + value).match(decimalNumberRegex);\n  if (!match || parseInt(match[1]) === 0) {\n    return 0;\n  }\n  return Math.max(\n    0,\n    // Number of digits right of decimal point.\n    (match[1] ? match[1].length : 0) -\n      // Adjust for scientific notation.\n      (match[2] ? +match[2] : 0),\n  );\n};\n\nexport function getDecimals(value: number): number {\n  if (decimalPlaces(value) > 0 && value > 0) {\n    return parseFloat(`0.${value.toString().split(\".\")[1]}`);\n  }\n  return value;\n}\n\nexport function remap(value: number, fromMin: number, fromMax: number, toMin: number, toMax: number): number {\n  return ((value - fromMin) * (toMax - toMin)) / (fromMax - fromMin) + toMin;\n}\n\n/**\n * Helper to determine if a value is close to the edge of a range within a threshold.\n *\n * @param value\n * @param range\n * @param threshold\n * @returns -1 if close to lower edge, 1 if close to upper edge, 0 otherwise.\n */\nexport function closeToRangeEdge(value: number, range: number, threshold: number): number {\n  return value < threshold ? -1 : value > range - threshold ? 1 : 0;\n}\n"],"names":["slopeSingle","p0","p1","m","dx","dy","bezier","m0","m1","t","x0","y0","x1","y1","h1","join","h2","p","area","data","min","max","length","_t2","startX","startY","_t4","minX","minY","maxX","_t6","commands","reduce","acc","point","i","p2","dx1","Math","sign","abs","slope","undefined","command","last","end","Graph","_inherits","_this","guid","createObserver","forceUpdate","this","resizeObserver","_this$resizeObserver","observe","el","key","value","_this$resizeObserver2","disconnect","colorStops","highlightMax","highlightMin","id","graphId","height","clientHeight","width","clientWidth","h","class","preserveAspectRatio","viewBox","x","y","range","rangeMin","rangeMax","currentMin","currentMax","rangeX","rangeY","translate","hMinX","_t8","hMaxX","_t10","areaPath","fill","x2","y2","map","offset","color","opacity","d","mask","get","HTMLElement","CSS","isRange","Array","isArray","Slider","event","mirror","shouldMirror","activeProp","pageStep","step","isActivationKey","preventDefault","adjustment","isNaN","fixedDecimalAdjustment","Number","toFixed","decimalPlaces","setValue","clamp","thumb","currentTarget","getAttribute","pointerDownDragStart","disabled","dragProp","clientX","pageX","minValueDragRange","maxValueDragRange","minMaxValueRange","newMinValue","newMaxValue","minValue","maxValue","isPrimaryPointerButton","dragEnd","removeDragListeners","focusActiveHandle","lastDragPropValue","emitChange","node","trackEl","minHandle","maxHandle","numberStringFormatter","locale","effectiveLocale","numberingSystem","useGrouping","groupSeparator","toString","newHistogram","hasHistogram","tickValues","generateTickValues","setMinMaxFromValue","setValueFromMinMax","connectInteractive","connectLocalized","connectLabel","connectForm","disconnectInteractive","disconnectLabel","disconnectForm","disconnectLocalized","setUpLoadableComponent","snap","getClosestStep","ticksWatcher","histogramWatcher","histogram","afterConnectDefaultValueSet","setComponentLoaded","labelHandles","adjustHostObscuredHandleLabel","precise","hyphenateCollidingRangeHandleLabels","hideObscuredBoundingTickLabels","updateHostInteraction","_this2","useMinValue","shouldUseMinValue","minInterval","getUnitInterval","maxInterval","valueIsRange","thumbTypes","buildThumbType","renderThumb","type","thumbPlacement","includes","minThumbTypes","minThumb","fillPlacement","trackRangePlacementStyles","left","right","Host","onKeyDown","handleKeyDown","onTouchStart","handleTouchStart","InteractiveContainer","getLabelText","scale","renderGraph","ref","storeTrackRef","onPointerDown","onTrackPointerDown","style","tick","tickOffset","activeTicks","rangeStart","rangeEnd","renderTickLabel","HiddenFormInputSlot","component","isLabeled","isPrecise","isMinThumb","valueProp","ariaLabel","minLabel","maxLabel","ariaValuenow","displayedValue","internalLabelFormatter","thumbStyle","thumbLabelClasses","labels","thumbContent","reverse","lastDragProp","onBlur","onThumbBlur","onFocus","onThumbFocus","onThumbPointerDown","storeThumbRef","role","tabIndex","histogramStops","labelTicks","isMinTickLabel","isMaxTickLabel","isAtEdge","position","prop","dragStart","shadowRoot","querySelector","_context","componentFocusable","handle","focus","thumbTypeParts","push","setFocus","mirrored","density","ticks","tickInterval","getTickDensity","current","window","addEventListener","dragUpdate","pointerUpDragEnd","valueX","getClosestHandle","calciteSliderInput","emit","calciteSliderChange","removeEventListener","values","valueChanged","Object","keys","forEach","propName","newValue","oldValue","_this3","emitInput","getBoundingClientRect","percent","clampedValue","bigDecimalString","BigDecimal","floor","multiply","add","snappedValue","getDistanceX","element","getComputedStyle","getPropertyValue","match","num","name","label","labelStatic","labelTransformed","labelStaticBounds","labelStaticOffset","getHostOffset","transform","leftModifier","rightModifier","leftValueLabel","leftValueLabelStatic","leftValueLabelTransformed","leftValueLabelStaticHostOffset","rightValueLabel","rightValueLabelStatic","rightValueLabelTransformed","rightValueLabelStaticHostOffset","labelFontSize","getFontSizeForElement","labelTransformedOverlap","getRangeLabelOverlap","hyphenLabel","labelOffset","classList","leftValueLabelTranslate","leftValueLabelTransformedHostOffset","rightValueLabelTranslate","rightValueLabelTransformedHostOffset","remove","minTickLabel","maxTickLabel","isMinTickLabelObscured","isMaxTickLabelObscured","leftBounds","rightBounds","hostBounds","leftLabel","rightLabel","leftLabelBounds","rightLabelBounds","leftLabelFontSize","rangeLabelOverlap","minLabelBounds","handleBounds","intersects","maxLabelBounds","customFormatter","labelFormatter","formatValue","formattedValue","decimalNumberRegex","RegExp","parseInt","getDecimals","parseFloat","split","remap","fromMin","fromMax","toMin","toMax","closeToRangeEdge","threshold"],"sourceRoot":""}