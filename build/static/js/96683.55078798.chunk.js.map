{"version":3,"file":"static/js/96683.55078798.chunk.js","mappings":"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","sources":["../node_modules/@esri/calcite-components/dist/components/node_modules/timezone-groups/dist/utils/continent.mjs","../node_modules/@esri/calcite-components/dist/components/node_modules/timezone-groups/dist/groupByOffset/index.mjs","../node_modules/@esri/calcite-components/dist/components/node_modules/timezone-groups/dist/utils/time-zones.mjs"],"sourcesContent":["const continentAllowList = new Set([\n    'Europe',\n    'Asia',\n    'America',\n    'America/Argentina',\n    'Africa',\n    'Australia',\n    'Pacific',\n    'Atlantic',\n    'Antarctica',\n    'Arctic',\n    'Indian',\n]);\nfunction extractContinent(label, strict = false) {\n    if (label.includes('Istanbul')) {\n        return 'Europe';\n    }\n    const indexFindFunction = strict ? 'indexOf' : 'lastIndexOf';\n    const separatorIndex = label[indexFindFunction]('/');\n    return separatorIndex === -1 ? label : label.slice(0, separatorIndex);\n}\nfunction isRegularContinent(continent) {\n    return continentAllowList.has(continent);\n}\n\nexport { extractContinent, isRegularContinent };\n","import { timeZones } from '../utils/time-zones.mjs';\nimport { extractContinent, isRegularContinent } from '../utils/continent.mjs';\n\nconst now = new Date();\nconst startDate = now.toISOString();\nconst daysInYear = 365;\nconst groupDateRange = daysInYear;\nconst defaultGroupingOptions = {\n    groupDateRange,\n    startDate,\n};\n\nconst _getDates = (startDate, numberDays, dateEngine) => {\n    const dateArray = [];\n    let date = dateEngine.create(startDate);\n    for (let i = 0; i <= numberDays; i++) {\n        date = dateEngine.increase(date);\n        dateArray.push(dateEngine.formatToIsoDateString(date));\n    }\n    return dateArray;\n};\nconst generateTimeZoneMetadata = (timeZoneItems, startDate, numberDays, dateEngine) => {\n    const processedDates = new Map();\n    const theDates = _getDates(startDate, numberDays, dateEngine);\n    return timeZoneItems.map((tzItem) => {\n        const { label } = tzItem;\n        const continent = extractContinent(label);\n        const dates = theDates.map((date) => {\n            const key = `${date}-${label}`;\n            let utc = processedDates.get(key);\n            if (utc) {\n                return utc;\n            }\n            utc = dateEngine.isoToTimeZone(date, label);\n            processedDates.set(key, utc);\n            return utc;\n        });\n        return {\n            ...tzItem,\n            continent,\n            isRegularContinent: isRegularContinent(continent),\n            dates,\n        };\n    });\n};\nconst compareDateArrs = (array1, array2, dateEngine) => array1.length === array2.length &&\n    array1.every((value, index) => dateEngine.same(value, array2[index]));\nconst getGroupLabelTimeZoneIndices = (rawTZs, max = 5) => {\n    const shrinkedTzs = rawTZs.filter(({ label }) => isRegularContinent(extractContinent(label)));\n    if (shrinkedTzs.length === 0) {\n        return [0];\n    }\n    const validLabels = shrinkedTzs.map((tz) => rawTZs.indexOf(tz));\n    return equallyDistributedSampling(validLabels, max);\n};\nfunction equallyDistributedSampling(items, maxItems = 5) {\n    const totalItems = items.length;\n    if (totalItems <= maxItems) {\n        return items;\n    }\n    const numberItemsToSelect = Math.min(totalItems - 2, maxItems - 2);\n    const stepSize = (totalItems - 1) / (numberItemsToSelect + 1);\n    return [\n        items[0],\n        ...Array.from({ length: numberItemsToSelect }, (_, i) => items[Math.round((i + 1) * stepSize)]),\n        items[totalItems - 1],\n    ];\n}\n\nasync function groupByOffset(options) {\n    const { groupDateRange, startDate, dateEngine } = {\n        ...defaultGroupingOptions,\n        ...options,\n    };\n    const grouping = [];\n    if (!dateEngine) {\n        throw new Error('dateEngine is required');\n    }\n    const timeZoneItems = timeZones.map((tz) => ({ label: tz }));\n    const timeZoneMetadata = generateTimeZoneMetadata(timeZoneItems, startDate, groupDateRange, dateEngine);\n    // We traverse the mappedDB and see if we find matches by comparing each set\n    // of transformed date for that specific TZ.\n    for (const tzMetadatumI of timeZoneMetadata) {\n        const { label, continent, dates } = tzMetadatumI;\n        if (tzMetadatumI.visited) {\n            continue;\n        }\n        tzMetadatumI.visited = true;\n        const newGroup = {\n            labelIdx: [],\n            tzs: [{ label }],\n        };\n        for (const tzMetadatumJ of timeZoneMetadata.filter((_) => !_.visited)) {\n            const { label: labelJ, continent: continentJ, isRegularContinent: isRegularContinentJ, dates: datesJ, } = tzMetadatumJ;\n            // We define a matching TZ by:\n            // 1) if both continents match (avoid grouping Antarctica with anything else)\n            // 2) if the transformed dates match in both TZs\n            if ((continent === continentJ || !isRegularContinentJ) &&\n                compareDateArrs(dates, datesJ, dateEngine)) {\n                const tzItem = { label: labelJ };\n                newGroup.tzs.push(tzItem);\n                tzMetadatumJ.visited = true;\n            }\n        }\n        grouping.push(newGroup);\n    }\n    // Now that we have a group, we want an easy way to find a fitting label for the group\n    // which is defined as the list of the most-common 7 cities, shown in alphabetical order\n    return grouping\n        .map((group) => {\n        group.tzs = group.tzs.sort((a, b) => a.label.localeCompare(b.label));\n        return {\n            labelTzIdx: getGroupLabelTimeZoneIndices(group.tzs, 7),\n            tzs: group.tzs.map((_) => _.label),\n        };\n    })\n        .sort((a, b) => b.tzs.length - a.tzs.length);\n}\n\nexport { groupByOffset };\n","const timeZones = (() => {\n    const platformTimeZones = Intl.supportedValuesOf('timeZone');\n    // Not all browsers include these time zones, so we add them to ensure consistent groups\n    const etcTimeZones = [\n        'Etc/GMT+1',\n        'Etc/GMT+10',\n        'Etc/GMT+11',\n        'Etc/GMT+12',\n        'Etc/GMT+2',\n        'Etc/GMT+3',\n        'Etc/GMT+4',\n        'Etc/GMT+5',\n        'Etc/GMT+6',\n        'Etc/GMT+7',\n        'Etc/GMT+8',\n        'Etc/GMT+9',\n        'Etc/GMT-1',\n        'Etc/GMT-10',\n        'Etc/GMT-11',\n        'Etc/GMT-12',\n        'Etc/GMT-13',\n        'Etc/GMT-14',\n        'Etc/GMT-2',\n        'Etc/GMT-3',\n        'Etc/GMT-4',\n        'Etc/GMT-5',\n        'Etc/GMT-6',\n        'Etc/GMT-7',\n        'Etc/GMT-8',\n        'Etc/GMT-9',\n    ];\n    return [...new Set([...platformTimeZones, ...etcTimeZones])];\n})();\n\nexport { timeZones };\n"],"names":["continentAllowList","Set","extractContinent","label","strict","includes","indexFindFunction","separatorIndex","slice","isRegularContinent","continent","has","defaultGroupingOptions","groupDateRange","startDate","Date","toISOString","generateTimeZoneMetadata","timeZoneItems","numberDays","dateEngine","processedDates","Map","theDates","dateArray","date","create","i","increase","push","formatToIsoDateString","_getDates","map","tzItem","dates","key","utc","get","isoToTimeZone","set","compareDateArrs","array1","array2","length","every","value","index","same","getGroupLabelTimeZoneIndices","rawTZs","max","shrinkedTzs","filter","validLabels","tz","indexOf","equallyDistributedSampling","items","maxItems","totalItems","numberItemsToSelect","Math","min","stepSize","Array","from","_","round","groupByOffset","_groupByOffset","options","_defaultGroupingOptio","grouping","_context","Error","timeZones","timeZoneMetadata","_iterator","tzMetadatumI","visited","newGroup","labelIdx","tzs","_iterator2","tzMetadatumJ","labelJ","continentJ","isRegularContinentJ","datesJ","group","sort","a","b","localeCompare","labelTzIdx","platformTimeZones","Intl","supportedValuesOf"],"sourceRoot":""}